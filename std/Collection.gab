return do (class)
  # --
  # Implement the collection interface for a class that implements:
  #   - put!
  #   - at
  #   - slice
  #   - each
  # --
  def [][class](key)
    ?key match
      ?{ from to } => self:slice(key.from, key.to) end
      ?{ from }    => self:slice(key.from)         end
      ?{ to }      => self:slice(0, key.to)  end
      .Number      => self:at(key)                 end
      else         => .INVALID_ARGUMENTS:panic     end
  end
  
  def [=][class](key, value)
    self:put!(key, value)
  end

  def fold[class](init, folder)
    v = init

    for i, index in self:each
        v = folder(v, i, index)
    end

    v
  end

  def filter[class](filterer)
    v = self:new

    for i, index in self:each
        filterer(i, index) and v:put!(index, i)
    end

    v
  end

  def map[class](mapper)
    v = self:new

    for i, index in self:each
        v:push!(mapper(i, index))
    end

    v
  end

  def fill[class](value)
    v = self:new

    for _, index in self:each
        self:put!(index, value)
    end

    v
  end

  def map![class](mapper)
      for i, index in self:each
          self:put!(index, mapper(i, index))
      end

      self
  end


  def fill![class](value)
      for _, index in self:each
        self:put!(index, value)
      end

      self
  end

  def compact[class]; self:filter do; not @1 == nil end end

  def join[class](sep)
    self:fold('') do (str, cur, i)
      i == 0 and '{cur}' or str + sep + '{cur}'
    end
  end

  def every?[class](pred)
    for i, _ in self:each
      pred(i) or return false
    end

    true
  end

  def some?[class](pred)
    for i, _ in self:each
      pred(i) and return true
    end

    false
  end

  def empty?[class]; self:len > 0 end

  def include?[class](value)
      for i, _ in self:each
          i == value and return true
      end

      false
  end

  def collect![class](..args)
    for ..all in args:splat
        self:put!(all:splat)
    end

    self
  end
end
