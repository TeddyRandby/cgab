def ()[.gab.message](r, ..args)
  r:(self)(..args)
end

def streams.fold[.gab.suspense](p, acc, cb)
  next_acc = cb(acc, ..p)            

  ..next_p, next_s = self()

  next_s:streams.fold(next_p, next_acc, cb)
end

def streams.fold[](p, acc, cb)
  acc
end

def fold[](msg, ..p, init, cb)
  acc, ..args, s = init, self:(msg)(..p)

  s:streams.fold(args, init, cb)
end

def streams.for[.gab.suspense](p, cb)
  cb(..p)

  ..args, s = self()

  s:streams.for(args, cb)
end

def streams.for[](p, cb)
  nil
end
def for[](msg, ..p, cb)
  ..args, s = self:(msg)(..p)

  s:streams.for(args, cb)
end

def streams.map[.gab.suspense](p, cb)
  yield cb(..p)

  ..args, s = self()

  s:streams.map(args, cb)
end

def streams.map[](p, cb)
  nil
end

def map[](msg, ..p, cb)
  ..args, s = self:(msg)(..p)

  s:streams.map(args, cb)
end

def streams.dofilter[true](p, s, cb)
  yield ..p

  ..args, next = s()

  next:streams.filter(args, cb)
end

def streams.dofilter[false](p, s, cb)
  ..args, next = s()

  next:streams.filter(args, cb)
end

def streams.filter[.gab.suspense](p, cb)
  cb(..p):streams.dofilter(p, self, cb)
end

def streams.filter[](p, cb)
  nil
end

def filter[](msg, ..p, cb)
  ..args, s = self:(msg)(..p)

  s:streams.filter(args, cb)
end

def streams.take[.gab.suspense](p, n, i)
  yield ..p

  def ..args, def next = self()

  (i < n):and => next:streams.take(args, n, i + 1)
end

def streams.take[](p, n, i)
  nil
end

def take[](msg, ..p, n)
  ..args, s = self:(msg)(..p)

  s:streams.take(args, n, 0)
end

def streams.dofirst[true](p, s, cb)
  ..p
end

def streams.dofirst[false](p, s, cb)
  ..args, next = s()

  next:streams.first(args, cb)
end

def streams.first[.gab.suspense](p, cb)
  res, ..vals = cb(..p)

  (res == .some):streams.dofirst(vals, self, cb)
end

def streams.first[](p, cb)
  .none
end

def first[](msg, ..p, cb)
  ..args, s = self:(msg)(..p)

  s:streams.first(args, cb)
end

def apply[](msgs)
  msgs:map(&:values) => self:(@1)
end

#def unwrap[](msg, ..p, cb)
#  x, ..args, s = self:(msg)(..p)
#
#  s:is? .gab.suspense then
#    cb(x) and yield ..args
#
#    loop
#
#      loop
#        x, ..args, s = s()
#        s:is? .gab.suspense or return
#      until cb(x) end
#
#      yield ..args
#    until not s:is? .gab.suspense end 
#  end
#end
#
#def join[](msg, ..p, sep, cb)
#  arg, .._, s = self:(msg)(..p)
#
#  s:is? .gab.suspense or return arg
#
#  acc, arg, .._, s = arg, s()
#
#  s:is? .gab.suspense and loop
#      acc = cb(acc, sep)
#      acc = cb(acc, arg)            
#      arg, .._, s = s()
#  until not s:is? .gab.suspense end
#
#  acc
#end
#
#
#def partition[](msg, ..p, n)
#  n > 1 or return
#
#  acc, i, ..args, s = :tuple.new(n), 0, self:(msg)(..p)
#
#  s:is? .gab.suspense and loop
#    loop
#      j, done = 0, args:len
#      loop
#        acc[i + j] = args[j]
#        j = j + 1
#      until j == done end
#      
#      ..args, s = s()
#      i = i + 1
#    until i == n or not s:is? .gab.suspense end
#
#    i == n and yield ..acc
#    i = 0
#  until not s:is? .gab.suspense end
#
#  acc
#end
