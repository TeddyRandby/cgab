:use .rec
:use .symbol

def record.exactly?[](rec)
  sym = :symbol.new('record.exactly?|{rec}')  

  def ==[?sym](other)
    rec:fold(&:keys, true) do (sofar, key)
      sofar and other:has?(key) and other[key] == rec[key]
    end
  end

  sym
end

def tuple.collect[](msg, *p, len)
  def t = :tuple.new(len)

  i, *args, s = 0, self:(msg)(p:splat)

  loop
    ?s == .Suspense or break

    t[i] = args:splat
    i = i + 1

    *args, s = s()
  until i == len end

  return t
end

def [][.Record](key)
  _, v = self:at(key)

  v
end

def [=][.Record](key, value); self:put!(key, value) end

def has?[.Record](key); self:at(key) == .some end

def pairs[.Record]
    key = self:next

    loop
      yield key, self[key]
      key = self:next(key)
    until key == nil end
end

def keys[.Record]
    key = self:next

    loop
      yield key
      key = self:next(key)
    until key == nil end
end

def values[.Record]
    key = self:next

    loop
      yield self[key]
      key = self:next(key)
    until key == nil end
end

def map![.Record](mapper)
    key = self:next

    loop
      self:put!(key, mapper(key, self:at(key)))
      key = self:next(key)
    until key == nil end

    self
end
