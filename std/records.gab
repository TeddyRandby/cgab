:use 'record'

def [][.Record](key)
  _, v = self:at(key) in match
    .some => return v end
    else => return nil end
end

def [=][.Record](key, value); self:put!(key, value) end

def first[.Record]; self:at(0) end

def last[.Record]; self:at(self:len - 1) end

def each[.Record]
    key = self:next

    loop
      yield key, self[key]
      key = self:next(key)
    until key == nil end
end

def keys[.Record]
    key = self:next

    loop
      yield key
      key = self:next(key)
    until key == nil end
end

def values[.Record]
    key = self:next

    loop
      yield self[key]
      key = self:next(key)
    until key == nil end
end

def map[.Record](mapper)
    other = :record(?self)

    for key, value in self:each
        other[key] = mapper(value)
    end

    return other
end

def map![.Record](mapper)
    for key, value in self:each
        self[key] = mapper(value, key)
    end

    return self
end

def fold[.Record](init, folder)
    acc = init

    for key, value in self:each
        acc = folder(acc, value)
    end

    return acc
end

def join[.Record](sep)
  self:fold('') do (str, cur, i)
    return i == 0 and '{cur}' or str + sep + '{cur}'
  end
end
