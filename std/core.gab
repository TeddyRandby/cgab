'cmessages':use
'cnumbers':use
'crecords':use
'cshapes':use
'cstrings':use

\self :def! ([], do; self end)
\first :def! ([], do x; x end)
\second :def! ([], do _, x; x end)

\is? :def! ([], do other; (self?) == (other?) end)

[] :defmodule! {
  [\and] = do alt[]
    alt**
  end,
  [\then] = do alt[], cb
    cb (alt**)
  end,
  [\or] = do 
    self
  end,
  [\else] = do 
    self
  end,
}

[.nil, .false, .none, .err] :defmodule! {
  [\and] = do
    self
  end,
  [\then] = do
    self
  end,
  [\or] = do alt[]
    alt**
  end,
  [\else] = do alt[], cb
    cb (alt**)
  end,
}

# The successfull case, unwrap into all the arguments.
\unwrap! :def! ([.ok], do args[]
  args**
end)

# All other types should panic when unwrapped
\unwrap! :def! ([.none, .err], do args[]
  'Cannot unwrap {self}':panic
end)

\unwrap :def! ([.ok], do args[]
  (.true, args**)
end)

\unwrap :def! ([.none, .err], do
  .false
end)

\options.into :def! ([.nil, .err, .false, .none], do args
  .none
end)

\options.into :def! ([.true, .ok], do args[]
  (.ok, args**)
end)

### The 'iter' module defines a protocol for producing an ordered sequence of values. 
### 
### The protocol consists of three messages:
###   - init
###   - next
###   - step
###
### The principle of the protocol is as follows:
###   The 'next' message must:
###     - Accept as the first argument the current 'key' into the sequence.
###       For lists, this could be the index, for maps, a literal key.
###     - Return a tuple of the form (<continue?>, <next-key>).
###       <continue?> dictates whether or not the sequence has a next value.
###         * [.nil, .false, .err, .none] all signal that the sequence is over.
###         * [.true, .ok] signal that the sequence has a next value. In this case,
###           the second element of the tuple is the next 'key', which will produce that next value.
###       
###   The 'step' message must:
###     - Accept as the first argument the current 'key' into the sequence.
###     - Return the value for that key.
###
###   The 'init' message must:
###     - Accept as the first argument the current 'key' into the sequence, or .nil.
###     - Return the current 'key', or transform .nil into the first 'key' in the sequence.
###
###
### Using the helpers defined in this module, defining an itererator
### looks like this:
###
### # Use the \next? builtin to determine if a list has a value after an index
### \lists.next? :def.iter.next! (lists.t, \next?)
### 
### # Use the \at! builtin to get the value at an index. This will never crash because
### #  it is never invoked with an index outside the bounds of the list.
### \lists.values.step :def.iter.step! \at!
### 
### # Define the \values iterator using these helpers.
### \values :def.iter! (lists.t, {
###   init = \numbers.into, # \numbers.into is a perfect init-message here because it converts .nil to 0.
###   next = \lists.next?,
###   step = \lists.values.step,
### })
###

# Define an 'iter' message using 'next' to check for and produce the next key.
\def.iter.next! :def! (['gab.message'], do t, next
  self :def! ([t], do n
    ok, nx = next (self, n)

    (ok, n, nx) :options.into
  end)
end)

# Define a 'step' message to produce values until the 'next' message returns .none
\def.iter.step! :def! (['gab.message'], do step
  # A step message dispatches
  # on the option returned by the 'next' message.
  self :defcase! {
    # In the case where there is a next value,
    # return a tuple:
    #  (.ok, next-key, current-value[])
    .ok = do i, n, nx
      (.ok, nx, step (i, n))
    end,
    # Otherwise, return .none
    .none = .none,
  }
end)

# Define an iterator using the given 'init', 'next', and 'step' messages.
\def.iter! :def! (['gab.message'], do t, args
  init, next, step = args:at! ('init', 'next', 'step')

  self :def! ([t], do n
    # Initialize the itererator with 'init'.
    # All next values will pass through 'init' as well,
    # so it should be designed to do nothing for that case.
    n = init (n, self)

    # Call 'next', with the invariant 'self' and the variant 'n'
    s, n, nx = next (self, n)

    # Dispatch to 'step', on 's'. This will terminate if
    # 'next' returned the sigil .none
    step (s, self, n, nx)
  end)
end)

# The work of reducing
\reduce :defcase! {
  .ok = do i, m, n, acc, xs, r
    # Apply the reducing function
    acc = r :reduce.step (acc, xs**)
    # Apply the producer, resolving new values for the next step
    s, n, xs[] = m (i , n)
    # Tailcall to the next step
    s :reduce (i, m, n, acc, xs, r)
  end,
  .none = do _i, _m, _n, acc, _xs, r
    r :reduce.done (acc)
  end,
}

# numbers:reduce(\values, 0, \+)
\reduce :def! ([], do m, acc, r
  s, n, xs[] = m self

  s :reduce (self, m, n, acc, xs, r)
end)

# numbers:transduce(\values, 0, \+, .td :map \++)
\transduce :def! ([], do m, acc, r, td
# Apply the transducer to the reducing function,
# And then just call a normal reduce
  self :reduce (m, acc, td r)
end)

# Implement the reducer protocol for blocks and messages
\reduce.step :def! (['gab.block', 'gab.message'], do acc, xs[]
  self (acc, xs**)
end)

\reduce.done :def! (['gab.block', 'gab.message'], do acc
  acc
end)

# A helper for declaring:
#   - a transducer's constructor
#     ie: (.td :map \++) constructs a mapping transducer, with \++
#   - a generic implementation for streams
#     ie: some_list :map (\values, 0, \+, \++)
\def.transducer! :def!(['gab.message'], do td
  self :def! ([.td], td)

  self :def! ([], do m, acc, rf, args[]
    self :transduce (m, acc, rf, td (args**))
  end)
end)

\td.conditionally :defcase! {
  .true = do acc, xs, rf
    rf :reduce.step (acc, xs**)
  end,
  .false = do acc
    acc
  end
}

\map :def.transducer! do f
  do rf
    do acc, xs[]
      rf:reduce.step(acc, f (xs**))
    end
  end
end

\filter :def.transducer! do f
  do rf
    do acc, xs[]
      (f (xs**)) :td.conditionally (acc, xs, rf)
    end
  end
end

\tap :def.transducer! do f
  do rf
    do acc, xs[]
      f (xs**)
      rf:reduce.step(acc, xs**)
    end
  end
end

\interpose :def.transducer! do sep
  do rf
    {
      started = .false,
      reduce.step = do acc, xs[]
        acc = self:started:td.conditionally (acc, [sep], rf)
        self:started = .true
        rf:reduce.step(acc, xs**)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\take :def.transducer! do n
  do rf
    {
      n,
      reduce.step = do acc, xs[]
        self:n = self:n - 1
        (self:n >= 0) :td.conditionally (acc, xs, rf)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\skip :def.transducer! do n
  do rf
    {
      n,
      reduce.step = do acc, xs[]
        self:n = self:n - 1
        (self:n < 0) :td.conditionally (acc, xs, rf)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\do_partition :defcase! {
  .true = do acc, state, rf
    state:n, xs = 0, state:d:slice(state:n)
    state:d:clear!
    rf (acc, xs**)
  end,
  .false = do acc, state, rf, xs
      acc
  end,
}

\partition :def.transducer! do n
  do rf
   {
      n = 0,
      d = .gab.tuple(n),
      reduce.step = do acc, xs[]
        self:d:put!(self:n, xs**)
        self:n = self:n + 1
        (self:n == n) :do_partition (acc, self, rf)
      end,
      reduce.done = do acc
        (self:n > 0) :do_partition (acc, self, rf)
      end,
    }
  end
end

\compose :defcase! {
  .nil = do f
    f
  end,
  gab.block = do g
# The following snippet is a bug which
# Caused the GC to overflow the stack for some reason.
# This definitely requires investigation.
#    do args[]
#      self(g(args**))
#    end
    f = self
    do args[]
      f(g(args**))
    end
  end,
}

\compose :def! ([.td], do fns[]
  fns :reduce (\values, .nil, \compose)
end)
