messages.t = 'cmessages':use
numbers.t = 'cnumbers':use
maps.t = 'cmaps':use
strings.t = 'cstrings':use
'format':use

truthy_values = []
falsey_values = [.nil, .false, .none, .err]

\self :def! ([], do: self end)
\first :def! ([], do x: x end)
\second :def! ([], do _, x: x end)

\is? :def! ([], do other: self:? == other end)

truthy_values :defmodule! {
  \and = do alt[]:
    alt**
  end,
  \then = do f:
    f()
  end,
  \or = do:
    self
  end,
  \else = do: 
    self
  end,
  \assert! = do:
    self
  end,
}

falsey_values :defmodule! {
  \and = do:
    self
  end,
  \then = do:
    self
  end,
  \or = do alt[]:
    alt**
  end,
  \else = do f:
    f()
  end,
  \assert! = do msg:
    'Assert failed: {msg}':panic
  end,
  \options.into = .none,
  \results.into = .err,
}

[] :defmodule! {
  \options.into = do args[]:
    (.ok, self, args**)
  end,
  \results.into = do args[]:
    (.ok, self, args**)
  end,
}

\ :def! ([.option], do cond, data[]:
  (cond:options.into, data**)
end)

[.ok] :defmodule! {
  \ok? = do args[]:
    (.true, args**)
  end,
  \unwrap = do args[]:
    args**
  end,
  \unwrap! = do args[]:
    args**
  end,
}

[.none, .err] :defmodule! {
  \ok? = .false,
  \unwrap = .nil,
  \unwrap! = do:
    'Cannot unwrap {self}':panic
  end,
}

\doreduce :defcase! {
  ## The sequence continues
  .ok = do seq.i, seq.v, acc, r, xs:
    # Apply the reducer
    cmd, r, acc = r:reduce.step(acc, xs**)
    # proceed to the next sep
    cmd:doreduce(seq.i, seq.v, acc, r)
  end,
  ## The sequence is done
  .none = do seq.i, seq.v, acc, r:
    r:reduce.done(acc)
  end,
  ## The reducer continues
  .next = do seq.i, seq.v, acc, r:
    # Apply the producer, resolving new values for the next step
    ok, seq.v, xs[] = seq.i :seqs.next seq.v
    # Tailcall to the next step
    ok:doreduce(seq.i, seq.v, acc, r, xs)
  end,
  ## The reducer is done
  .stop = do seq.i, seq.v, acc, r:
    r:reduce.done(acc)
  end,
}

\def.seq! :def! ([], do:
  [self] :defmodule! {
    \reduce = do acc, r:
      ok, seq.v, xs[] = self :seqs.init
      ok:doreduce(self, seq.v, acc, r, xs)
    end,
    \transduce = do acc, r, td:
      self:reduce(acc, td :iter.apply r)
    end,
    \tuples.into = do:
      self:reduce({}, \push)
    end,
    \each = do f:
      self:transduce(.nil, \self, .map f)
    end,
  }
end)

# Implement the reducer protocol for blocks and messages
['gab.block', 'gab.message'] :defmodule! {
  \reduce.step = do acc, xs[]:
    (.next, self, self(acc, xs**))
  end,
  \reduce.done = do acc:
    acc
  end,
}

[maps.t] :defmodule! {
  \has? = do key:
    self:at key :ok?
  end,
  \at! = do key:
    self:at key :unwrap!
  end,
}

maps.t :def.seq!

\ :def! ([.int.between], do min, max:
  .float.between (min,max) :floor
end)


range.t = { from, to }?

range.t :def.seq!
[range.t] :defmodule! {
  seqs.init = do: (.ok, self:from) end,
  seqs.next = do n:
    nx = n + 1
    .option(n < self:to, nx, nx)
  end,
}

\range.into :defcase! {
  .nil = do to:
    { from = 0, to }
  end,
  'gab.number' = do from:
    { from, to = self }
  end,
}




\ :def! ([.range], do from, to:
  (to, from) :range.into
end)

\is_n? :def! ([], .false)
\is_n? :def! ([numbers.t], .true)

\numbers.into :def!(falsey_values, 0)

[numbers.t] :defmodule! {
  ++ = do: self + 1 end,
  -- = do: self - 1 end,
  even? = do: (self % 2) == 0 end,
  odd? = do: self:even?:! end,
  pos? = do: self > 0 end,
  neg? = do: self < 0 end,
  numbers.into = do: self end,
}
