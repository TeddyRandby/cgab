messages.t = 'cmessages':use
numbers.t = 'cnumbers':use
maps.t = 'cmaps':use
strings.t = 'cstrings':use
'format':use

truthy_values = []
falsey_values = [.nil, .false, .none, .err]

\self :def! ([], do: self end)
\first :def! ([], do x: x end)
\second :def! ([], do _, x: x end)

\is? :def! ([], do other: self:? == other end)

truthy_values :defmodule! {
  \and = do alt[]:
    alt**
  end,
  \then = do f:
    f()
  end,
  \or = do :
    self
  end,
  \else = do: 
    self
  end,
  \assert! = do:
    self
  end,
}

falsey_values :defmodule! {
  \and = do:
    self
  end,
  \then = do:
    self
  end,
  \or = do alt[]:
    alt**
  end,
  \else = do f:
    f()
  end,
  \assert! = do msg:
    'Assert failed: {msg}':panic
  end,
  \options.into = .none,
  \results.into = .err,
}

[] :defmodule! {
  \options.into = do args[]:
    (.ok, self, args**)
  end,
  \results.into = do args[]:
    (.ok, self, args**)
  end,
}

\ :def! ([.option], do cond, data[]:
  (cond:options.into, data**)
end)

[.ok] :defmodule! {
  \ok? = do args[]:
    (.true, args**)
  end,
  \unwrap = do args[]:
    args**
  end,
  \unwrap! = do args[]:
    args**
  end,
}

[.none, .err] :defmodule! {
  \ok? = .false,
  \unwrap = .nil,
  \unwrap! = do:
    'Cannot unwrap {self}':panic
  end,
}

\doreduce :defcase! {
  ## The sequence continues
  .ok = do seq.i, seq.v, acc, r, xs:
    # Apply the reducer
    acc, cmd = r:reduce.step(acc, xs**)
    # proceed to the next sep
    cmd:doreduce(seq.i, seq.v, acc, r)
  end,
  ## The sequence is done
  .none = do seq.i, seq.v, acc, r:
    r:reduce.done(acc)
  end,
  ## The reducer continues
  .nil = do seq.i, seq.v, acc, r:
    # Apply the producer, resolving new values for the next step
    ok, seq.v, xs[] = seq.i :seqs.next seq.v
    # Tailcall to the next step
    ok:doreduce(seq.i, seq.v, acc, r, xs)
  end,
  ## The reducer is done
  .stop = do seq.i, seq.v, acc, r:
    r:reduce.done(acc)
  end,
}

\def.seq! :def! ([], do next:
  [self] :defmodule! {
    \seqs.next = next,
    \reduce = do acc, r:
      ok, seq.v, xs[] = self :seqs.next .seqs.init
      ok:doreduce(self, seq.v, acc, r, xs)
    end,
    \transduce = do acc, r, td:
      self:reduce(acc, td :iter.apply r)
    end,
    \tuples.into = do:
      self:reduce({}, \push)
    end,
    \each = do f:
      self:transduce(.nil, \self, .map f)
    end,
  }
end)

# Implement the reducer protocol for blocks and messages
['gab.block'] :defmodule! {
  \reduce.step = do acc, xs[]:
    self(acc, xs**)
  end,
  \reduce.done = do acc:
    acc
  end,
}

['gab.message'] :defmodule! {
  \reduce.step = do acc, xs[]:
    acc:send(self, xs**)
  end,
  \reduce.done = do acc:
    acc
  end,
}

['gab.block'] :defmodule! {
  \|> = do td:
    self :iter.compose td
  end,
  \iter.compose = do second:
    first = self;
    do r:
      second:iter.apply(first:iter.apply r)
    end
  end,
  \iter.apply = do r:
    self r
  end,
}

# A helper for declaring:
#   - a transducer's constructor
#     ie: (.td :map \++) constructs a mapping transducer, with \++
\def.transducer! :def!(['gab.message'], do r:
 self :def!([.td], r)
end)

\td.conditionally :defcase! {
  .true = do acc, xs, r:
    r:reduce.step (acc, xs**)
  end,
  .false = do acc:
    acc
  end,
}

\td.stop_conditionally :defcase! {
  .true = do acc, xs, r:
    r:reduce.step(acc, xs**)
  end,
  .false = do acc:
    (acc, .stop)
  end,
}

\map :def.transducer! do f:
  do r:
    do acc, xs[]:
      r:reduce.step(acc, f(xs**))
    end
  end
end

\td.filter.into :defcase! {
  'gab.message' = do:
    f = self
    do r:
      do acc, x, xs[]:
        x:send(f, xs**):td.conditionally(acc, [x, xs**], r)
      end
    end
  end,
  'gab.block' = do:
    f = self
    do r:
      do acc, xs[]:
        f(xs**):td.conditionally(acc, xs, r)
      end
    end
  end,
}

\filter :def.transducer! \td.filter.into

\td.tap.into :defcase! {
  'gab.message' = do:
    f = self
    do r:
      do acc, x, xs[]:
        x:send(f, xs**)
        r:reduce.step(acc, x, xs**)
      end
    end
  end,
  'gab.block' = do:
    f = self
    do r:
      do acc, xs[]:
        f(xs**)
        r:reduce.step(acc, xs**)
      end
    end
  end,
}

\tap :def.transducer! \td.tap.into

\compose :defcase! {
  .nil = do f:
    f
  end,
  'gab.block' = do g:
# The following snippet is a bug which
# Caused the GC to overlow the stack.
# This definitely requires investigation.
# Infinitely calls itself, allocating more and more.
#    do args[]
#      self(g(args**))
#    end
    f = self
    do args[]:
      f(g(args**))
    end
  end,
}

\compose :def! ([.td], do fns[]:
  fns:transduce(.nil, \compose, .td :map \first)
end)

[maps.t] :defmodule! {
  \has? = do key:
    self:at key :ok?
  end,
  \at! = do key:
    self:at key :unwrap!
  end,
}

maps.t :def.seq! do v:
  ok, nk, nv = self:next v
  (ok, nk, nk, nv)
end

\ :def! ([.int.between], do min, max:
  .float.between (min,max) :floor
end)

\range.into :defcase! {
  .nil = do to:
    { from = 0, to }
  end,
  'gab.number' = do from:
    { from, to = self }
  end,
}

\ :def! ([.range], do from, to:
  (to, from) :range.into
end)

\is_n? :def! ([], .false)

\is_n? :def! ([numbers.t], .true)

\numbers.into :def!(falsey_values, 0)

[numbers.t] :defmodule! {
  ++ = do: self + 1 end,
  -- = do: self - 1 end,
  even? = do: (self % 2) == 0 end,
  odd? = do: self:even?:! end,
  pos? = do: self > 0 end,
  neg? = do: self < 0 end,
  numbers.into = do: self end,
}
