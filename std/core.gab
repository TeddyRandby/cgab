'cmessages':use
'cnumbers':use
'crecords':use
'cshapes':use
'cstrings':use

\self :def! ([], do; self end)
\first :def! ([], do x; x end)
\second :def! ([], do _, x; x end)

\is? :def! ([], do other; (self?) == (other) end)

[] :defmodule! {
  \and = do alt[]
    alt**
  end,
  \then = do alt[], f
    f (alt**)
  end,
  \or = do 
    self
  end,
  \else = do 
    self
  end,
  \assert! = do
    self
  end,
}

[.nil, .false, .none, .err] :defmodule! {
  \and = do
    self
  end,
  \then = do
    self
  end,
  \or = do alt[]
    alt**
  end,
  \else = do alt[], f
    f (alt**)
  end,
  \assert! = do msg
    'Assert failed: {msg}':panic
  end,
  \options.into = .none,
  \results.into = .err,
}

\options.into :def! ([], do args[]
  (.ok, self, args**)
end)

\results.into :def! ([], do args[]
  (.ok, self, args**)
end)

\ :def! ([.gab.option], do cond, data[]
  (cond:options.into, data**)
end)

[.ok] :defmodule! {
  \unwrap! = do args[]
    args**
  end,
  \unwrap = do args[]
    (.true, args**)
  end,
}

[.none, .err] :defmodule! {
  \unwrap! = do
    'Cannot unwrap {self}':panic
  end,
  \unwrap = .false,
}

### The 'iter' module defines a protocol for producing an ordered sequence of values. 
### 
### The protocol consists of three messages:
###   - init
###   - next
###   - step
###
### The principle of the protocol is as follows:
###   The 'next' message must:
###     - Accept as the first argument the current 'key' into the sequence.
###       For lists, this could be the index, for maps, a literal key.
###     - Return a tuple of the form (<continue?>, <next-key>).
###       <continue?> dictates whether or not the sequence has a next value.
###         * [.nil, .false, .err, .none] all signal that the sequence is over.
###         * [.true, .ok] signal that the iteruence has a next value. In this case,
###           the second element of the tuple is the next 'key', which will produce that next value.
###       
###   The 'step' message must:
###     - Accept as the first argument the current 'key' into the iteruence.
###     - Return the value for that key.
###
###   The 'init' message must:
###     - Accept as the first argument the current 'key' into the iteruence, or .nil.
###     - Return the current 'key', or transform .nil into the first 'key' in the iteruence.
###
###
### Using the helpers defined in this module, defining an itererator
### looks like this:
###
### # Use the \next? builtin to determine if a list has a value after an index
### \lists.next? :def.iter.next! (lists.t, \next?)
### 
### # Use the \at! builtin to get the value at an index. This will never crash because
### #  it is never invoked with an index outside the bounds of the list.
### \lists.values.step :def.iter.step! \at!
### 
### # Define the \values iter using these helpers.
### \values :def.iter! (lists.t, {
###   init = \numbers.into, # \numbers.into is a perfect init-message here because it converts .nil to 0.
###   next = \lists.next?,
###   step = \lists.values.step,
### })
###

# Define an 'iter' message using 'next' to check for and produce the next key.
\def.iter.next! :def! (['gab.message'], do t, next
  self :def! (t, do n
    ok, nx = next (self, n)

    .gab.option (ok, n, nx)
  end)
end)

# Define a 'step' message to produce values until the 'next' message returns .none
\def.iter.step! :def! (['gab.message'], do step
  # A step message dispatches
  # on the option returned by the 'next' message.
  self :defcase! {
    # In the case where there is a next value,
    # return a tuple:
    #  (.ok, next-key, current-values)
    .ok = do i, n, nx
      (.ok, nx, step (i, n))
    end,
    # Otherwise, return .none
    .none = .none,
  }
end)

# Define an iter using the given 'init', 'next', and 'step' messages.
\def.iter! :def! (['gab.message'], do t, args
  init, next, step = args:at! ('init', 'next', 'step')

  self :def! (t, do n
    # Initialize the itererator with 'init'.
    # All next values will pass through 'init' as well,
    # so it should be designed to do nothing for that case.
    n = init (n, self)

    # Call 'next', with the invariant 'self' and the variant 'n'
    s, n, nx = next (self, n)

    # Dispatch to 'step', on 's'. This will terminate if
    # 'next' returned the sigil .none
    step (s, self, n, nx)
  end)
end)

seqs.t = {
  seq.i, # Invariant
  seq.m, # The seq message to send to Invariant
  seq.s, # The status
  seq.n, # The next 'key' to produce the next value
}?

\ :def! ([.gab.seq], do i, m
  {
    seq.i = i,
    seq.m = m,
    seq.s = .ok,
    seq.n = .seqs.init,
  }
end)

\seq.into :def! ([], do m
  .gab.seq (self, m)
end)

\seq.step :defcase! {
  .ok = do seq
    seq:seq.s, seq:seq.n, xs[] = (seq:seq.m)(seq:seq.i, seq:seq.n)
    xs
  end,
  .none = do seq
    ()
  end,
}

\reduce.next :defcase! {
  .nil = do i, acc, r
    # Apply the producer, resolving new values for the next step
    xs = i:seq.s:seq.step i
    # Tailcall to the next step
    i:seq.s:reduce(i, acc, r, xs)
  end,
  .stop = do _i, acc, r
    r:reduce.done(acc)
  end,
}

# The work of reducing
\reduce :defcase! {
  .ok = do s, acc, r, xs
    # Apply the reducer
    acc, cmd = r:reduce.step(acc, xs**)
    # proceed to the next sep
    cmd:reduce.next(s, acc, r)
  end,
  .none = do s, acc, r
    r:reduce.done(acc)
  end,
}

[seqs.t] :defmodule! {
  \reduce = do acc, r
    self:print
    xs = self:seq.s:seq.step self

    self:seq.s:reduce(self, acc, r, xs)
  end,
  \transduce = do acc, r, td
    xs = self:seq.next

    self:seq.s:reduce(self, acc, td r, xs)
  end,
  \lists.into = do
    self:reduce(.gab.list(), \push!)
  end,
  \tuples.into = do
    self:reduce({}, \push)
  end,
}

# Implement the reducer protocol for blocks and messages
['gab.block', 'gab.message'] :defmodule! {
  \reduce.step = do acc, xs[]
    acc = self (acc, xs**)
  end,
  \reduce.done = do acc
    acc
  end,
}

# A helper for declaring:
#   - a transducer's constructor
#     ie: (.td :map \++) constructs a mapping transducer, with \++
#   - a generic implementation for streams
#     ie: some_list :map (\values, 0, \+, \++)
\def.transducer! :def!(['gab.message'], do td
  self :def! ([.td], td)
end)

\td.conditionally :defcase! {
  .true = do acc, xs, rf
    rf:reduce.step (acc, xs**)
  end,
  .false = do acc
    acc
  end,
}

\td.stop_conditionally :defcase! {
  .true = do acc, xs, rf
    rf:reduce.step(acc, xs**)
  end,
  .false = do acc
    (acc, .stop)
  end,
}

\map :def.transducer! do f
  do rf
    do acc, xs[]
      rf:reduce.step(acc, f (xs**))
    end
  end
end

\filter :def.transducer! do f
  do rf
    do acc, xs[]
      (f (xs**)) :td.conditionally (acc, xs, rf)
    end
  end
end

\tap :def.transducer! do f
  do rf
    do acc, xs[]
      f (xs**)
      rf:reduce.step(acc, xs**)
    end
  end
end

\interpose :def.transducer! do sep
  do rf
    {
      started = .false,
      reduce.step = do acc, xs[]
        acc = self:started:td.conditionally (acc, [sep], rf)
        self:started = .true
        rf:reduce.step(acc, xs**)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\take :def.transducer! do n
  do rf
    {
      n,
      reduce.step = do acc, xs[]
        self:n = self:n - 1
        (self:n >= 0) :td.stop_conditionally (acc, xs, rf)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\skip :def.transducer! do n
  do rf
    {
      n,
      reduce.step = do acc, xs[]
        self:n = self:n - 1
        (self:n < 0) :td.conditionally (acc, xs, rf)
      end,
      reduce.done = do acc
        acc
      end,
    }
  end
end

\do_partition :defcase! {
  .true = do acc, state, rf
    state:n, xs = 0, state:d:slice(state:n)
    state:d:clear!
    rf (acc, xs**)
  end,
  .false = do acc, state, rf, xs
      acc
  end,
}

\partition :def.transducer! do n
  do rf
   {
      n = 0,
      d = .gab.tuple(n),
      reduce.step = do acc, xs[]
        self:d:put!(self:n, xs**)
        self:n = self:n + 1
        (self:n == n) :do_partition (acc, self, rf)
      end,
      reduce.done = do acc
        (self:n > 0) :do_partition (acc, self, rf)
      end,
    }
  end
end

\compose :defcase! {
  .nil = do f
    f
  end,
  gab.block = do g
# The following snippet is a bug which
# Caused the GC to overflow the stack.
# This definitely requires investigation.
# Infinitely calls itself, allocating more and more.
#    do args[]
#      self(g(args**))
#    end
    f = self
    do args[]
      f(g(args**))
    end
  end,
}

\compose :def! ([.td], do fns[]
  .gab.seq(fns, \values) :reduce(.nil, \compose)
end)
