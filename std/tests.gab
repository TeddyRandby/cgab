:use 'streams'
:use 'records'
:use 'lists'

TestState = .{ fails, errs }?

&:testState :def! do
    :record.new(TestState):reset
end

&:reset :def!(TestState) do
    self:fails = 0
    self:errs = :list.new

    self
end

&:fail :def!(TestState) do (got, expected)
    self:fails = self:fails + 1
    self:errs:push!([got, expected])
end

&:passed? :def!(TestState) =>
    self:fails == 0

&:show_errs :def! (TestState) =>
    self:errs:for(&:values) do (mismatch)
        '     - got {mismatch[0]}, expecting {mismatch[1]}':print
    end

def T = :testState

&:expect :def! do (other)
    self == other :or => T:fail(self, other)
end

&:expect_not :def! do (other)
    (self == other) :and => T:fail(self, other)
end

&:describe :def! do (name, cb)
  '\n{name}:':print
  cb()
end

&:it :def! do (name, cb)
  T:reset

  cb()

  '  {(T:passed?:and => '✓') :or => '×'} it {name}':print

  T:passed?:or => T:show_errs
end
