'streams' :use
records = 'records' :use
lists = 'lists' :use

TestState = { fails, errs }

\reset :def! (TestState, do
  self:fails = 0
  self:errs = lists:list.new

  self
end)

T = records:make(TestState ?):reset 

\tests.push_result :def! {

# When the result is true, we do nothing.
# The test passed.
  [true]  = do
    nil
  end,

# When the result is false, The test failed.
# Count it and add it to the list of fails.
  [false] = do actual, expected
    T:fails = T:fails + 1
    T:errs:push! [actual, expected]
  end,

}

\passed? :def! (TestState, do
  self:fails == 0
end)

\show_errs :def! (TestState, do
  self:errs:for(\values, do mismatch
      '     - got {mismatch:at(0)}, expecting {mismatch:at(1)}':print
  end)
end)

\should :def! do msg, ..args, other
    self :{msg} (..args, other) :tests.push_result(self, other)
end

\be :def! do msg, other
  self :{msg} other
end

\not.be :def! do msg, other
  (self :{msg} other)!
end

\describe :def! do name, cb
  '\n{name}:':print
  cb()
end

\it :def! do name, cb
  T:reset

  cb()

  '  { T:passed? :and '✓' :or '×' } it { name }':print end

  T:passed?:or do; T:show_errs end
end
