require('object')

def ARRAY = $array

def make[ARRAY](..values)
    {
        len = values and values:len or 0
        data = values or []
    }
end

def Array { len data }

def __set__[Array](index, arg)
    index? match
        Number => self.data[index] = arg
        else => panic("Invalid call to Array:__set__")
end

def __get__[Array](opts)
    opts? match
        { from to }? => self.data:slice(opts.from, opts.to)
        { from }?    => self.data:slice(opts.from)
        { to }?      => self.data:slice(nil, opts.to)
        Number       => self.data[opts]
        else         => panic('Invalid call to Array:__get__')
end

def __itr__[Array]
    let v = -1 

    loop
        v = v + 1
        yield self.data[v], v
    until v >= self.len
end

def print[Array]
    for v, i in self
        print(i)
    end
end

def len[Array]
    self.len
end

def first[Array]
    self[0]
end

def last[Array]
    self[self.len - 1]
end

def push[Array](..values)
    for index in values:len:to
        self[self.len + index] = values[index]
    end

    self.len = self.len + values:len
end

def pop[Array]
    self[self.len = self.len - 1]
end

def slice[Array](opts, to)
    opts? match
        { from to }? => self.data:slice(opts.from, opts.to)
        { from }?    => self.data:slice(opts.from)
        { to }?      => self.data:slice(nil, opts.to)
        Number       => self.data:slice(opts)
        else         => panic('Invalid call to Array:slice')
end

def join[Array](sep)
    self:fold('', do (str, curr) str + String:from(curr) end)
end

def fold[Array](init, folder)
    let v = init

    for i in self
        v = folder(v, i)
    end

    v
end

def filter[Array](filterer)
    let v = ARRAY:make

    for i in self
        filterer(i) and v:push(i)
    end

    v
end

def map[Array](mapper)
    let v = ARRAY:make

    for i in self
        v:push(mapper(i))
    end

    v
end

ARRAY
