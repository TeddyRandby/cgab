'msg' :use
'rec' :use

td.t = .td

# A helper for declaring:
#   - a transducer's constructor
#     ie: (.td :map \++) constructs a mapping transducer, with \++
#   - a generic implementation for streams
#     ie: some_list :map (\values, 0, \+, \++)
\deftransducer! :def!(['gab.message'], do td
  self :def! ([td.t], td)

  self :def! ([], do m, acc, rf, args[]
    self :transduce (m, acc, rf, td (args**))
  end)
end)

\td.conditionally :defcase! {
  .true = do acc, xs, rf
    rf(acc, xs**)
  end,
  .false = do acc
    acc
  end
}

\map :deftransducer! do f
  do rf
    do acc, xs[]
      rf(acc, f (xs**))
    end
  end
end

\filter :deftransducer! do f
  do rf
    do acc, xs[]
      (f (xs**)) :td.conditionally (acc, xs, rf)
    end
  end
end

\take :deftransducer! do n
  do rf
    state = { n }
    do acc, xs[]
      state:n = state:n - 1
      (state:n >= 0) :td.conditionally (acc, xs, rf)
    end
  end
end

\skip :deftransducer! do n
  do rf
    state = { n }
    do acc, xs[]
      state:n = state:n - 1
      (state:n < 0) :td.conditionally (acc, xs, rf)
    end
  end
end

\tap :deftransducer! do f
  do rf
    do acc, xs[]
      f (xs**)
      rf(acc, xs**)
    end
  end
end

\do_partition :defcase! {
  .true = do acc, state, rf
    state:n, xs = 0, state:d:slice
    state:d:clear!
    rf (acc, xs**)
  end,
  .false = do acc, state, rf
      state:n = state:n + 1
      acc
  end,
}

\partition :deftransducer! do n
  do rf
    state = {
      n = 0,
      d = .gab.tuple :make n,
    }
    do acc, xs[]
      state:d:put!(state:n, xs**)
      (state:n == n) :do_partition (acc, state, rf)
    end
  end
end
