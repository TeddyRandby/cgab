def lists.t = :use .list

&[] :def!(lists.t) do (key)
  self:at(key)
end

&[=] :def!(lists.t) do (key, val)
  self:put!(key, val)
end

&:lists.build :def!(lists.t) do (l, p)
  l:push!(p)

  &:..args, def next = self()

  next:lists.build(l, args)
end

&:lists.build :def! do (l, p)
  l:push!(p)
end

&:lists.collect :def! do (msg, ..p)
  &:l = :list.new

  ..args, s = self:(msg)(..p)

  s:lists.build(l, args)
end

&:lists.values :def!(lists.t) do (i)
  self:len > i :and do
    yield self:at(i)
    self:lists.values(i + 1)
  end
end

&:values :def!(lists.t) do
  self:lists.values(0)
end

&:lists.pairs :def!(lists.t) do (i)
  self:len > i :and do
    yield i, self:at(i)
    self:lists.pairs(i + 1)
  end
end

&:pairs :def!(lists.t) =>
  self:lists.pairs(0)

&<< :def!(lists.t) do (other)
  other:for(&:values) => self:push!(@1)
  
  self
end

&:empty? :def!(lists.t) =>
  self:len == 0
