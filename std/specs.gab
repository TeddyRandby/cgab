:use .maps
:use .records
:use .lists
:use .shapes
:use .symbol
:use .numbers
:use .msg
:use .any
:use .assert
:use .streams

def explain_specs(specs, separator)
  not specs and return ''

  specs :tuple.collect(
            &:map,
            &:values,
            &:spec.explain,
            specs:len,
       ):join(
            &:values,
            separator,
            &+,
       )
end

def explain_strings(strings, separator)
  inner = strings :tuple.collect(
                      &:map,
                      &:values,
                      do (v); '{v} = {:spec(v):spec.explain}' end,
                      strings:len,
                  ):join(
                      &:values,
                      separator,
                      &+,
                  )
end

## Registry of qualified name -> spec
def registry.spec = :map.new

## Registry of spec -> qualified name
def registry.name = :map.new

## Registry of qualified name -> help text
def registry.help = :map.new

## Registry of receiver -> list of spec'd messages
def registry.messages = :map.new

def register(registry, name, value)
  # Add a new specification to the registry.
  # If this key already existed, panic.
  registry:add!(name, value) == .ok or .SPEC_NAME_TAKEN:panic
end

## Add a spec to the global registry under the given name.
def spec.def![](name, opts)
  register(registry.spec, name, opts:spec)
  register(registry.name, opts:spec, name)

  opts:has? .help then
    register(registry.help, opts:spec, opts:help)
  end

  opts:spec
end

def spec[](name)
  s, v = registry.spec:at(name)

  s == .some or 'Could not find spec "{name}"':panic

  v
end

def spec.help[]
  registry.help:at(self)
end

def spec.name[]
  s, v = registry.name:at(self)

  s == .some or 'spec {self} is not named':panic

  v
end

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

# NIL PREDICATE
def nil.predicate = :symbol.new 'predicate:nil'

def spec.fits?[?nil.predicate](value)
  return value == nil, self, value
end

def spec.gen[?nil.predicate]
  nil
end

def spec.explain[?nil.predicate](); 'nil' end

def spec.nil[]; nil.predicate end

# UNKNOWN PREDICATE
def unknown.predicate = :symbol.new 'predicate:unknown'

def spec.fits?[?unknown.predicate](value)
  return true, self, value
end

def unknown_values = [ nil, 0, 1, 'test', true ]

def spec.gen[?unknown.predicate]
  idx = :int.between(0, unknown_values:len - 1)

  unknown_values[idx]
end

def spec.explain[?unknown.predicate](); 'unknown' end

def spec.unknown[]; unknown.predicate end

# INT PREDICATE
def int.predicate = :symbol.new 'predicate:int'

def spec.fits?[?int.predicate](value)
  return value:is_n?, self, value
end

def spec.gen[?int.predicate]
  :int.between(-10000, 10000)
end

def spec.explain[?int.predicate](); 'int' end

def spec.int[]; int.predicate end

#
# FLOAT PREDICATE
#

def float.predicate = :symbol.new 'predicate:float'

def spec.fits?[?float.predicate](value)
  return value:is_n?, self, value
end

def spec.gen[?float.predicate]
  :float.between(-10000, 10000)
end

def spec.explain[?float.predicate](); 'float' end

def spec.float[]; return float.predicate end

#
# STRING PREDICATE
#
def string.predicate = :symbol.new 'predicate:string'

def spec.fits?[?string.predicate](value)
  return value:is_s?, self, value
end

def spec.gen[?string.predicate]
  def len  = :int.between(1, 100)
  def list = :list.new
  
  i = 0
  
  loop
    list:push!(:int.between(0, 127))
    i = i + 1
  until i == len end
  
  list:to_bytes
end

def spec.explain[?string.predicate](); 'string' end

def spec.string[]; string.predicate end

#
# BOOL PREDICATE
#
def bool.predicate = :symbol.new 'predicate:bool'

def spec.fits?[?bool.predicate](value)
  return value:is_b?, self, value
end

def spec.gen[?bool.predicate]
  :float.between > 0.5
end

def spec.explain[?bool.predicate](); 'bool' end

def spec.bool[]; return bool.predicate end

## predicate for a map of key type -> value type
def spec.map[](k_spec, v_spec)
  def map.predicate = :symbol.new 'predicate:map:{k_spec}:{v_spec}'

  def spec.fits?[?map.predicate](value)
    ?value == .Map or return false, self, value 
    
    value:for(&:pairs) do (k, v)
      k_spec:spec.fits?(k) or return false, k_spec, k, k
      v_spec:spec.fits?(v) or return false, v_spec, v, k
    end

    return true, self, value
  end

  def spec.gen[?map.predicate]
    :map.new { [k_spec:spec.gen] =  v_spec:spec.gen }
  end

  def spec.explain[?map.predicate](k_spec, v_spec)
    'map[{k_spec},{v_spec}]'
  end

  map.predicate
end

## predicate for a list of values
def spec.list[](spec)
  def list.predicate = :symbol.new 'predicate:list:{spec}'

  def spec.fits?[?list.predicate](value)
    ?value == .List or return false, self, value

    value:for(&:pairs) do (k, v)
      spec:spec.fits?(v) or return false, self, value, k
    end

    return true, self, value
  end

  def spec.gen[list.predicate]
    :list.new:push!(spec:spec.gen)
  end

  def spec.explain[?list.predicate](spec)
    'list[{spec}]'
  end

  list.predicate
end

## predicate for a type which implements a set of messages
def spec.protocol[](protocol)
  def protocol.predicate = :symbol.new 'predicate:protocol:{protocol}'
# Return a predicate which returns true if the given value
# has all the keys of the record
  def spec.fits?[?protocol.predicate](value)
    protocol:for(&:keys) do (k)
# If message doesn't specify for this value, then the spec doesn't fit
      m = :message.new(k)
      m:has?(value) or return false, self, k

# Check for a spec which corresponds to this message in the protocol
      res, s = registry.spec:at(k)
      
      res == .some and s:spec.fits?(value[k]) else
        return false, s, value, k
      end

    end

    return true, self, value
  end

  def spec.gen[?protocol.predicate]
    def gen = :record.new(protocol)

    protocol:for(&:keys) do (k)
      s, found = registry.spec:at(k)

      s == .some or .MISSING_SPEC:panic

      gen[k] = found:spec.gen
    end

    return gen
  end

  def spec.explain[?protocol.predicate]
    "{\n " + explain_strings(protocol, '\n ') + "\n}"
  end

  protocol.predicate
end

def spec.tuple[](..specs)
  def tuple.predicate = :symbol.new 'predicate:tuple:{specs}'

  def spec.fits?[?tuple.predicate](..values)
     ..specs:fold(
              &:pairs,
              [ true, tuple.predicate, values, nil ],
              do (a, i, s)
                # Stop at the first failing spec
                a[0] or a

                success, sp, value, path = s:spec.fits?(values[i])

                # If our spec fits, continue with the initial value.
                # Otherwise, return the result from the failed spec
                success and a or [success, sp, value, path]
              end,
         )
  end

  def spec.gen[?tuple.predicate]
    res = :tuple.new(specs:len)

    res:map! do (k)
      specs[k]:spec.gen
    end

    res
  end

  def spec.explain[?tuple.predicate]
    explain_specs(specs, ', ')
  end

  tuple.predicate
end

## Convenience specs for composing above types
def spec.result[](value, err)
  :spec.or(
    :spec.tuple(.ok, value),
    err,
  )
end

def spec.option[](value)
  :spec.or(
    :spec.tuple(.some, value),
    .none,
  )
end

def spec.or[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  
  def or.predicate = :symbol.new 'predicate:or:{specs}'
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  def spec.fits?[?or.predicate](value)
    valid = specs:fold(&:values, false) do (acc, s)
      acc or s:spec.fits?(value)
    end
    
    return valid, self, value
  end

  def spec.gen[?or.predicate]
    specs[(:int.between(0, specs:len - 1))] :spec.gen
  end

  def spec.explain[?or.predicate]
    explain_specs(specs, ' | ')
  end

  return or.predicate
end

def spec.and[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic

  def and.predicate = :symbol.new 'predicate:and:{specs}'
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  def spec.fits?[?and.predicate](value)
    specs:for(&:pairs) do (k, spec)
      spec:spec.fits?(value) or return false, spec, value, k
    end
    
    return true, self, value
  end
  
  def spec.gen[?and.predicate]
    tries = 0
    
    start = specs[0]
    loop
      def value = start:spec.gen
      tries = tries + 1

      valid = specs:fold(&:values, true) do (a, s)
        a and s:spec.fits?(value)
      end

      valid and return value

    until tries == 100 end

    .SPEC_COULD_NOT_GEN:panic
  end

  def spec.explain[?and.predicate]
    explain_specs(specs, ' & ')
  end

  return and.predicate
end

# Modifying specs
def spec.gt[](min)
  def gt.predicate = :symbol.new 'predicate:gt:{min}'

  def spec.fits?[?gt.predicate](value)
    return value > min, self, value
  end

  def spec.explain[?gt.predicate](); '> {min}' end

  gt.predicate
end

def spec.lt[](min)
  def lt.predicate = :symbol.new 'predicate:lt:{min}'

  def spec.fits?[?lt.predicate](value)
    return value < min, self, value
  end

  def spec.explain[?lt.predicate](); '< {min}' end

  lt.predicate
end

def spec.block.Args { input, output }

def spec.block[](args, semantics)
  args:assert.is?(spec.block.Args)

  def block.predicate = :symbol.new 'predicate:block:{args}:{semantics}'

  def spec.fits?[?block.predicate](input, output)
    success, pred, val, path = args:input:spec.fits?(..input)
    success or return false, pred, input, .input
    
    success, pred, val, path = args:output:spec.fits?(..output)
    success or return false, pred, output, .output

    semantics or return success, self, [input, output]

    return semantics(input, output), self, [input, output], .semantics
  end

  def spec.gen[?block.predicate]
    def block.gen(..input)
      loop
        # Generate an output
        ..output = args:output:spec.gen

        args:output:spec.fits?(..output) then
          # If there are no semantics to satisfy, just return this output
          semantics or return ..output
          
          # Otherwise, we need to continue generating until we
          # find an output which satisfy the semantics for the input.
          semantics(input, output) and return ..output
        end
      end
    end
  end

  def spec.check[?block.predicate](block)
    loop
      ..input  = args:input:spec.gen

      args:input:spec.fits?(..input) then
        ..output = block(..input)
        
        yield block.predicate(input, output)
      end
    end
  end
  
  return block.predicate
end

## TODO: Handle -
##    - no arguments
##    - no output
##    - no receiver
def spec.message.Args { receiver, message, input, output }

def spec.message[](args, semantics)
  args:assert.is?(spec.message.Args)

  def message.predicate = :symbol.new 'predicate:message:{args}:{semantics}'

  registry.messages:at_or!(
                      args:receiver,
                      :map.new,
                  ):add!(
                      args:message,
                      message.predicate,
                  )

  def spec.fits?[?message.predicate](rec, input, output)
    success, pred, val, path = args:input:spec.fits?(..input)
    success or return false, pred, input, .input
    
    success, pred, val, path = args:output:spec.fits?(..output)
    success or return false, pred, output, .output
    
    success, pred, val, path = args:receiver:spec.fits?(rec)
    success or return false, pred, rec, .receiver

    semantics or return success, self, [rec, input, output]

    return semantics(rec, input, output), self, [rec, input, output], .semantics
  end

  def spec.gen[?message.predicate](receiver)
    def message.gen(..input)
      args:input:spec.fits?(..input) or .INVALID_ARGUMENTS:panic

      loop
# Generate an output
        ..output = args:output:spec.gen

        args:output:spec.fits?(..output) then
          # If there are no semantics to satisfy, just return this output
          semantics or return ..output
          
          rec = args:receiver:spec.gen

          args:receiver:spec.fits?(rec) then 
            # Otherwise, we need to continue generating until we
            # find a receiver and output which satisfy the semantics.
            semantics(rec, input, output) then
              # Woohoo! modify self to reflect the generated receiver
              self:spec.modify!(rec)

              # Return the generated output
              return ..output
            end
          end
        end
      end
    end
    
    args:message:put!(receiver, message.gen)

    return args:message
  end

  def spec.check[?message.predicate]
    loop
      receiver = args:receiver:spec.gen

      args:receiver:spec.fits?(receiver) then
        ..input  = args:input:spec.gen

        args:input:spec.fits?(..input) then
          ..output = receiver:(args:message)(..input)
          
          yield self:spec.fits?(receiver, input, output)
        end
      end
    end
  end

  def spec.explain[?message.predicate]
    name = self:spec.name

    has_help, help = self:spec.help

    '\n{name}: { has_help and help or '' }\n| {args:message}[{args:receiver:spec.name}]({args:input:spec.explain}) -> {args:output:spec.explain}\n'
  end

  return message.predicate
end

def LabeledSpec { spec.label, spec.spec }
def spec.labeled[](spec.spec, spec.label); { spec.label, spec.spec } end
def spec.gen[LabeledSpec]; self:spec.spec:spec.gen end
def spec.fits?[LabeledSpec]; self:spec.spec:spec.fits? end
def spec.explain[LabeledSpec]; '{self:spec.label}:' +  self:spec.spec:spec.explain end
def spec.modify![LabeledSpec](new_value); self:spec.spec:spec.modify!(new_value) end
def spec.check[LabeledSpec]; self:spec.spec:spec.check  end

# A default gen implementation is the identity function
def spec.gen[]; self end

# A default explain implementation
def spec.explain[]; '{self}' end

def spec.messages[]
  has, messages = registry.messages:at(self) 

  has == .some and
    messages:for(&:values, &:spec.explain)
end

## FITS
# Default spec.fits? specializfation is just good ol' equality
def spec.fits?[](value)
  return self == value, self, value
end

# Since a spec is just a predicate, we can simply call it and return the result
def spec.fits?[.Block](value); self(value)      end

## MODIFY
# Because it is common for messages to modify `self`, spec
# needs a way to emulate this in messages that it generates.
# User types can define their own version of &:spec.modify! If this
# Doesn't satisfy their use case.
def spec.modify![.Record](new_value)
    self:for(&:keys) do (k)
      # If new_value has a corresponding value, modify self. Else, pass
      s, v = new_value:at(k)

      s == .some then
        self[k] = v
      end
  end
end

return nil
