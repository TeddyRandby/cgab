'core' :use
'maps':use
'lists':use
'records':use
'numbers' :use

explain_specs = do specs, separator
  specs:transduce(
    \values,
    '',
    \+,
    .td:compose (
      .td:map \spec.explain,
      .td:interpose separator,
    ),
  )
end

explain_strings = do strings, separator
  strings:transduce(
    \keys,
    '',
    \+,
    .td:compose (
      .td:map do name
        '{name} = {name:spec:spec.explain}'
      end,
      .td:interpose separator,
    ),
  )
end

## Registry of qualified name -> spec
registry.spec = .gab.map {}

## Registry of spec -> qualified name
registry.name = .gab.map {}

## Registry of qualified name -> help text
registry.help = .gab.map {}

## Registry of receiver -> list of spec'd messages
registry.messages = .gab.map {}

register = do registry, name, value
  # Add a new specification to the registry.
  # If this key already existed, panic.
  registry:add!(name, value):unwrap!
end


\spec.register! :defcase! {
  [{ spec }?] = do name
    register(registry.spec, name, self:spec)
    register(registry.name, self:spec, name)

    self:spec
  end,
  [{ help, spec }?] = do name
    register(registry.spec, name, self:spec)
    register(registry.name, self:spec, name)
    register(registry.help, self:spec, self:help)

    self:spec
  end,
  [{ spec, help }?] = do name
    register(registry.spec, name, self:spec)
    register(registry.name, self:spec, name)
    register(registry.help, self:spec, self:help)

    self:spec
  end,
}

## Add a spec to the global registry under the given name.
\def.spec! :def! (['gab.string'], do opts
  opts :spec.register! self
end)

\spec :def! ([], do
  registry.spec:at(self):unwrap!
end)

\spec.help :def! ([], do
  registry.help:at(self)
end)

\spec.name :def! ([], do
  registry.name:at(self):unwrap!
end)

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

# NIL PREDICATE
nil.predicate = .predicate.nil

\spec.fits? :def! ([nil.predicate], do value
  (value == .nil, self, value)
end)

\spec.gen :def! ([nil.predicate], do
  .nil
end)

\spec.explain :def! ([nil.predicate], 'Nil')

\ :def! ([.spec.nil], nil.predicate)

# UNKNOWN PREDICATE
unknown.predicate = .predicate.unknown

\spec.fits? :def! ([unknown.predicate], do value
  (.true, self, value)
end)

unknown_values = [ .nil, 0, 1, 'test', .true ]

\spec.gen :def! ([unknown.predicate], do
  idx = .int.between(0, unknown_values:len - 1)

  unknown_values:at!(idx)
end)

\spec.explain :def! ([unknown.predicate], 'Unknown')

\ :def! ([.spec.unknown], unknown.predicate)

registry.name:put!(unknown.predicate, 'unknown')

# INT PREDICATE
int.predicate = .predicate.int

\spec.fits? :def! ([int.predicate], do value
  (value:is_n?, self, value)
end)

\spec.gen :def! ([int.predicate], do
  .int.between(-10000, 10000)
end)

\spec.explain :def! ([int.predicate], 'Int')

\ :def! ([.spec.int], int.predicate)

#
# FLOAT PREDICATE
#

float.predicate = .predicate.float

\spec.fits? :def! ([float.predicate], do value
  (value:is_n?, self, value)
end)

\spec.gen :def! ([float.predicate], do
  .float.between(-10000, 10000)
end)

\spec.explain :def! ([float.predicate], 'Float')

\ :def! ([.spec.float], float.predicate)

#
# STRING PREDICATE
#
string.predicate = .predicate.string

\spec.fits? :def! ([string.predicate], do value
  (value:is_s?, self, value)
end)

\spec.gen :def! ([string.predicate], do
  len  = .int:between(1, 100)
  list = .gab.list()

  len:times => list:push!(.int:between(0, 127))
  
  list:to_bytes
end)

\spec.explain :def! ([string.predicate], 'String')

\ :def! ([.spec.string], string.predicate)

#
# SHAPE PREDICATE
#

shape.predicate = .predicate.shape

\spec.fits? :def! ([shape.predicate], do value
  (value:is_shape?, self, value)
end)

\spec.gen :def! ([shape.predicate], do
  { a, b, c }?
end)

\spec.explain :def! ([shape.predicate], 'Shape')

\ :def! ([.spec.shape], shape.predicate)

#
# BOOL PREDICATE
#
boolean.predicate = .predicate.boolean

\spec.fits? :def! ([boolean.predicate], do value
  (value:is_b?, self, value)
end)

\spec.gen :def! ([boolean.predicate], do
  .float:between > 0.5
end)

\spec.explain :def! ([boolean.predicate], 'Boolean')

\ :def! ([.spec.boolean], boolean.predicate)

\spec.recursively :defcase! {
  # In the boolean cases, recurse if the spec matched
  # and bail early if it didn't
  .true = do tail, curr, alt
    tail:spec.recursively(alt**)
  end,
  .false = do tail, curr, alt
    (self, curr**)
  end,
  # In the recursion cases, continue to check head 
  # until there is no tail
  .nil = do alt[]
    alt**
  end,
  ['gab.record'] = do alt[]
    spec, value = self:head**

    does_fit, result[] = spec :spec.fits? value

    does_fit :spec.recursively (self:tail, result, alt)
  end,
}

## predicate for a map of key type -> value type
\ :def! ([.spec.map], do k_spec, v_spec
  map.predicate = 'predicate:map:{k_spec}:{v_spec}' :sigil.into

  \spec.fits?:def! ([map.predicate], do value
    (value ? == .gab.map) :and do
      (.false, self, value)
    end :or do
      value :for(
        \pairs,
        do k, v
          [ [k_spec, k], [v_spec, v] ] :spec.recursively
        end,
        )

       (.true, self, value)
    end
  end)

  \spec.gen :def! ([map.predicate], do
    .gab.map { [k_spec:spec.gen] =  v_spec:spec.gen }
  end)

  \spec.explain :def! ([map.predicate], do
    'Map[{k_spec:spec.explain}: {v_spec:spec.explain}]'
  end)

  map.predicate
end)

## predicate for a list of values
\spec.list :def! ([], do spec
  list.predicate = 'predicate:list:{spec}' :sigil.into

  \spec.fits? :def! ([list.predicate], do value
    value:spec.fits_each?(\values)
  end)

  \spec.gen :def! ([list.predicate], do
    .gab.list():push!(spec:spec.gen)
  end)

  \spec.explain :def! ([list.predicate], do
    'list[{spec:spec.explain}]'
  end)

  list.predicate
end)

## predicate for a type which implements a set of messages
\ :def! ([.spec.protocol], do protocol
  protocol_shape = protocol?
  protocol.predicate = 'predicate:protocol:{protocol}' :sigil.into
# Return a predicate which returns true if the given value
# has all the keys of the record
  \spec.fits? :def! ([protocol.predicate], do value
    protocol:spec.fits_each?(\keys, do k
# If message doesn't specify for this value, then the spec doesn't fit
      m = .gab.message k

# Check for a spec which corresponds to this message in the protocol
      m:has?(value) :and (.false, self, k, do
       registry.spec:at(k) :unwrap:and (.false, self, value, k, do res, s
          s:spec.fits?(value:at!(k))
        end)
      end)

      (.true, self, value)
    end)
  end)

  \spec.gen :def! ([protocol.predicate], do
    gen = .gab.record protocol_shape

    protocol:map(\keys, gen, \put!, do key
      found = registry.spec:at(key):unwrap!

      { key, found }:print

      (key, found:spec.gen)
    end,
    )
  end)

  \spec.explain :def! ([protocol.predicate], do
    (protocol:len == 0) :and "{}" :or ("{\n " + explain_strings(protocol, '\n ') + "\n}")
  end)

  protocol.predicate
end)

\ :def! ([.spec.values], do specs[]
  values.predicate = 'predicate:values:{specs}' :sigil.into

  \spec.fits? :def! ([values.predicate], do values[]
     specs:reduce(
              \pairs,
              [ .true, values.predicate, values, .nil ],
              do a, i, s
                # Stop at the first failing spec
                # a[0] or a

                success, sp, value, path = s:spec.fits?(values[i])

                # If our spec fits, continue with the initial value.
                # Otherwise, return the result from the failed spec
                success :and([success, sp, value, path], a)
              end,
         )**
  end)

  \spec.gen :def! ([values.predicate], do
    res = .gab.tuple specs:len

    res:map! do k
      specs:at!(k):spec.gen
    end

    res
  end)

  \spec.explain :def!([values.predicate], do
    explain_specs(specs, ', ')
  end)

  values.predicate
end)

## Convenience specs for composing above types
\ :def! ([.spec.result], do value, err
  .spec:or(
    .spec:values(.ok, value),
    err,
  )
end)

\ :def! ([.spec.option], do value
  .spec:or(
    .spec:values(.ok, value),
    .none,
  )
end)

\ :def! ([.spec.or], do specs[]
  specs:len > 0 :or do
    'INVALID_ARGUMENTS':panic
  end
  
  or.predicate = 'predicate:or:{specs}' :sigil.into
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  \spec.fits? :def! ([or.predicate], do value
    valid = specs:fold(\values, .false) do acc, s
      acc :or => s:spec.fits?(value)
    end
    
    (valid, self, value)
  end)

  \spec.gen :def! ([or.predicate], do
    specs:at!(.int.between(0, specs:len - 1)) :spec.gen
  end)

  \spec.explain :def! ([or.predicate], do
    explain_specs(specs, ' | ')
  end)

   or.predicate
end)

\ :def! ([.spec.and], do specs[]
  specs:len > 0 :or do
    'INVALID_ARGUMENTS':panic
  end

  and.predicate = 'predicate:and:{specs}' :sigil.into
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  \spec.fits? :def! ([and.predicate], do value
    specs:for(\pairs, do k, spec
      spec:spec.fits?(value) :or => (.false, spec, value, k)
    end)
    
    (.true, self, value)
  end)
  
  \spec.gen :def! ([and.predicate], do
    start = specs :at 0

    100:until(\upto, 0, \self, do
      value = start:spec.gen

      specs:fold(\values, .true, do a, s
        a :and => s:spec.fits?(value)
      end)
    end)
  end)

  \spec.explain :def! ([and.predicate], do
    explain_specs(specs, ' & ')
  end)

   and.predicate
end)

# Modifying specs
\ :def! ([.spec.gt], do min
  gt.predicate = 'predicate:gt:{min}' :sigil.into

  \spec.fits? :def! ([gt.predicate], do value
    (value > min, self, value)
  end)

  \spec.explain :def!([gt.predicate], '> {min}')

  gt.predicate
end)


\ :def! ([.spec.lt], do max
  lt.predicate = 'predicate:lt:{max}' :sigil.into

  \spec.fits? :def ([lt.predicate], do value
    (value < max, self, value)
  end)

  \spec.explain :def! ([lt.predicate], '< {max}')

  lt.predicate
end)

spec.block.Args = { input, output, semantics }?

spec.block.Application = { input, output, semantics, in, out }?

\spec.block.input_fits? :def! ([spec.block.Application], do
  self:input:spec.fits?(self:in**)
end)

\spec.block.output_fits? :def! ([spec.block.Application], do
  self:output:spec.fits?(self:out**)
end)

\spec.semantic_fits? :def! ([.nil], do input, output
  (.true, .nil, [input, output])
end)

\spec.semantics_fits? :def! ([.gab.block], do input, output
  (self(input, output), self, [input, output], .semantics)
end)

\spec.block.semantics_fits? :def! ([spec.block.Application], do input, output
  self:at!(.semantics):spec.semantic_fits?(input, output)
end)

\ :def! ([.spec.block], do args, semantics
  args:assert.is?(spec.block.Args)

  block.predicate = 'predicate:block:{args}:{semantics}' :sigil.into

  \spec.fits? :def! ([block.predicate], do input, output
    v = args:with(.input_value, input):with(.output_value, output)

    v:first(
      \apply,
      [
        \spec.block.input_fits?,
        \spec.block.output_fits?,
        \spec.semantic_fits?,
      ],
      \option.into,
    )
  end)

  \spec.gen :def! ([block.predicate], do
    block.gen = do input[]
      100:first(\upto, do
        # Generate an output
        output[] = args:output:spec.gen

        v = args:with(.input_value, input):with(.output_value, output)

        v:first(
          \apply,
          [
            \spec.block.input_fits?,
            \spec.block.output_fits?,
            \spec.semantic_fits?,
          ],
          \option.into,
        )
      end):unwrap!
    end
  end)

  \spec.check :def! ([block.predicate], do block
    100:first(\upto, do
      input[]  = args:input:spec.gen

      args:input:spec.fits?(input**) :and do
        output[] = block(input**)
        
        (.some, block.predicate(input, output))
      end
    end)
  end)
  
  block.predicate
end)

general_message.predicate = 'predicate:message' :sigil.into

\spec.fits? :def! ([general_message.predicate], do value
  (value:is_m?, self, value)
end)

\spec.gen :def! ([general_message.predicate], \+)

\spec.explain :def! ([general_message.predicate], 'Message')

spec.message.Args = { receiver, message, input, output, semantics }?

spec.message.Application = spec.message.Args :with .in :with .out :with .rec

\spec.message.input_fits? :def! ([spec.message.Application], do
  self:input:spec.fits?(self:in**)
end)

\spec.message.output_fits? :def! ([spec.message.Application], do
  self:output:spec.fits?(self:out**)
end)

\spec.message.receiver_fits? :def! ([spec.message.Application], do
  self:receiver:spec.fits?(self:rec**)
end)

\spec.message.semantics_fits? :def! ([spec.message.Application], do input, output
  self:at!('semantics'):spec.semantic_fits?(input, output)
end)

\spec.message.define :def! ([.nil], general_message.predicate)

\spec.message.define :def! ([spec.message.Args], do 
  args = self
  message.predicate = 'predicate:message:{args}' :sigil.into

  registry.messages:at_or!(
      args:receiver,
      .gab.map {},
  ):add!(
      args:message,
      message.predicate,
  )

  \spec.fits? :def! ([message.predicate], do rec, input, output
    v = args:with(.input_value, input):with(.output_value, output)

    v:first(
      \apply,
      [
        \spec.message.input_fits?,
        \spec.message.output_fits?,
        \spec.message.receiver_fits?,
        \spec.message.semantics_fits?,
      ],
      \option.into,
    )
  end)

  \spec.gen :def! ([message.predicate], do receiver
    args:message :def! ([receiver], do input[]
      args:input:spec.fits?(input**) :and(.false, do 
        100:first(\upto, do
    # Generate an output
          output[] = args:output:spec.gen

          args:output:spec.fits?(output**) :and do
            # If there are no semantics to satisfy, just return this output
            (args:semantics :or do; output** end) :and do
              rec = args:receiver:spec.gen

              args:receiver:spec.fits?(rec) :and do 
                # Otherwise, we need to continue generating until we
                # find a receiver and output which satisfy the semantics.
                args:semantics(rec, input, output) :and do
                  # Woohoo! modify self to reflect the generated receiver
                  self:spec.modify!(rec)

                  # Return the generated output
                  output**
                end
              end
            end
          end
        end)
      end)
    end)

    args:message
  end)

  \spec.check :def! ([message.predicate], do
    100:first(\upto, do
      receiver = args:receiver:spec.gen

      args:receiver:spec.fits?(receiver) :and do
        input[]  = args:input:spec.gen

        args:input:spec.fits?(input**) :and do
          output[] = args:message(receiver, input**)
          
          self:spec.fits?(receiver, input, output)
        end
      end
    end)
  end)

  \spec.explain :def! ([message.predicate], do
    '{args:message}[{args:receiver:spec.name}]({args:input:spec.explain}) -> {args:output:spec.explain}'
  end)

  message.predicate
end)

\ :def! ([.spec.message], do args
  args:spec.message.define
end)

LabeledSpec = { spec.label, spec.spec }

\spec.label :def! ([], do spec.spec, spec.label
  { spec.label, spec.spec }
end)

\spec.explain :def! ([LabeledSpec ?], do
  '{self:spec.label}: {self:spec.spec:spec.explain}'
end)

\spec.gen :def! ([LabeledSpec ?], do
  self:spec.spec:spec.gen
end)

\spec.fits? :def! ([LabeledSpec ?], do
  self:spec.spec:spec.fits?
end)

\spec.check :def! ([LabeledSpec ?], do
  self:spec.spec:spec.check
end)

\spec.modify! :def! ([LabeledSpec ?], do
  self:spec.spec:spec.modify!
end)

# A default gen implementation is the identity function
\spec.gen :def! ([], do; self end)

# A default explain implementation
\spec.explain :def! ([], do; '{self}' end)

\spec.doc :def! ([], do
  name, help = registry.name:at!(self), registry.help:at!(self)

  '## {name}\n{help}\n\n\t{self:spec.explain}\n'
end)

\spec.messages :def! ([], do
  registry.messages:at(self):unwrap:and do a
    a:for(\map, \values, \spec.doc, \print)
  end
end)

## FITS
# Default spec.fits? specializfation is just good ol' equality
\spec.fits? :def! ([], do value
  (self == value, self, value)
end)

# Since a spec is just a predicate, we can simply call it and return the result
\spec.fits? :def! ([.gab.block], do value; self(value) end)

## MODIFY
# Because it is common for messages to modify `self`, spec
# needs a way to emulate this in messages that it generates.
# User types can define their own version of \spec.modify! If this
# Doesn't satisfy their use case.
\spec.modify! :def! ([.gab.record], do new_value
    self:for(\keys, do k
      # If new_value has a corresponding value, modify self. Else, pass
      v = new_value:at(k):unwrap:and do other
        self:at!(k) = other
      end
  end)
end)
