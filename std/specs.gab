:use 'maps'
:use 'records'
:use 'lists'
:use 'message'
:use 'any'
:use 'symbol'

def spec.invalid = :symbol.new('spec.invalid')

## Registry of qualified name -> spec
def registry.spec = :map.new

## Registry of qualified name -> help text
def registry.help = :map.new

def register(registry, name, value)
  # Add a new specification to the registry.
  # If this key already existed, panic.
  result = registry:add!(name, value) in match
     .ok  => .pass                  end
     else => .SPEC_NAME_TAKEN:panic end
end

## Add a spec to the global registry under the given name.
def spec.def![](name, spec)
  ?spec match
    ?{ spec } => 
      register(registry.spec, name, spec:spec)
    end
    ?{ spec help } => 
      register(registry.spec, name, spec:spec)
      register(registry.help, name, spec:help)
    end
    else => register(registry.spec, name, spec) end
end

def spec[](name)
  _, s = registry.spec:at(name) in match
    .some => return s            end
    else  => .MISSING_SPEC:panic end
end

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

def spec.int[]
  def int.predicate(value)
    return value:is_n?, self, value
  end

  def spec.gen[int.predicate]; :int.between(-10000, 10000) end

  return int.predicate
end

def spec.float[]
  def float.predicate(value)
    return value:is_n?, self, value
  end
  
  def spec.gen[float.predicate]; :float.between(-10000, 10000) end

  return float.predicate
end

def spec.string[]
  def string.predicate(value)
    return value:is_s?, self, value
  end

  def spec.gen[string.predicate]
    def len  = :int.between(1, 100)
    def list = :list.new
    
    i = 0
    
    loop
      list:push!(:int.between(0, 127))
      i = i + 1
    until i == len end
    
    list:to_bytes
  end

  return string.predicate
end

def spec.gt[](min)
  def gt.predicate(value)
    return value > min, self, value
  end
end

def spec.lt[](min)
  def lt.predicate(value)
    return value < min, self, value
  end
end

## predicate for a map of key type -> value type
def spec.map[](k_spec, v_spec)
  def map.predicate (value)
    ?value == .Map or return false, self, value 
    
    for k, v in value:each
      k_spec:spec.fits?(k) or return false, k_spec, k, k
      v_spec:spec.fits?(v) or return false, v_spec, v, k
    end

    return true, self, value
  end

  def spec.gen[map.predicate]
    :map.new { [k_spec:spec.gen] = v_spec:spec.gen }
  end

  return map.predicate
end

## predicate for a list of values
def spec.list[](spec)
  def list.predicate (value)
    ?value == .List or return false, self, value

    for v, i in value:each
      spec:spec.fits?(v) or return false, self, value, i
    end

    return true, self, value
  end

  def spec.gen[list.predicate]
    :list.new:push!(spec:spec.gen)
  end

  return list.predicate
end

## predicate for a list of keys
def spec.record[](record)
  # Return a predicate which returns true if the given value
  # has all the keys of the record
  def record.predicate (value)
    ## TODO: Update this such that the value is AT LEAST the record
    value:is?(record) or return false, self, value

    for k in :record.new(record):each
      # If the value has the shape we expect,
      # then we can continue on and check each
      # of its keys against a possible spec
      # in the registry.
      _, s = registry.spec:at(k) in match
         .some => s:spec.fits?(value[k]) else
              return false, s, value, k
            end
         end
         else  => .MISSING_SPEC:panic end
    end

    return true, self, value
  end

  def spec.gen[record.predicate]
    gen = :record.new(record)

    for k in :record.new(record):each
      _, s = registry.spec:at(k) in match
        .some => gen[k] = s:spec.gen end
        else  => .MISSING_SPEC:panic end
    end

    return gen
  end

  return record.predicate
end

def spec.or[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  def or.predicate (value)
    for k, spec in specs:each
      spec:spec.fits?(value) and return true, spec, value, k
    end
    
    return false, self, value
  end

  def spec.gen[or.predicate]
    specs[(:int.between(0, specs:len - 1))] :spec.gen
  end

  return or.predicate
end

def spec.and[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  def and.predicate (value)
    for k, spec in specs:each
      spec:spec.fits?(value) or return false, spec, value, k
    end
    
    return true, self, value
  end
  
  def spec.gen[and.predicate]
    tries = 0
    
    start = specs[0]
    loop
      value, valid, tries = start:spec.gen, false, tries + 1

      for s in specs:values
        valid = s:spec.fits?(value)
        valid or break
      end

      valid and return value

    until tries == 100 end

    .SPEC_COULD_NOT_GEN:panic
  end

  return and.predicate
end

def spec.block.Args { input output }

def spec.block[](args, semantics)
  args:is?(spec.block.Args) or .INVALID_ARGUMENTS:panic

  def block.predicate(value)
    ..before = args:input:spec.gen

    ..after = value(before:splat)

    success, pred, val, path = args:output:spec.fits?(after:splat)

    semantics and success or return success, self, before, path

    return semantics(before, after), self, before
  end

  def spec.gen[block.predicate]
    def block.gen(..input)
      args:input:spec.fits?(input:splat) or .INVALID_ARGUMENTS:panic

      return args:output:spec.gen
    end
  end
  
  return block.predicate
end

def spec.message.Args { message receiver input output }

def spec.message[](args, semantics)
  args:is?(spec.message.Args) or .INVALID_ARGUMENTS:panic

  def message.predicate(rec, input, output)
    success, pred, val, path = args:input:spec.fits?(input:splat)
    success or return success, pred, val, .input
    
    success, pred, val, path = args:output:spec.fits?(output:splat)
    success or return success, pred, val, .output
    
    success, pred, val, path = args:receiver:spec.fits?(rec)
    success or return success, pred, val, .receiver
    
    semantics or return success, self, [rec, input, output]

    return semantics(rec, input, output), self, [rec, input, output], .semantics
  end

  def spec.gen[message.predicate](receiver)
    def message.gen(..input)
      args:input:spec.fits?(input:splat) or .INVALID_ARGUMENTS:panic

      loop
        # Generate an output
        ..output = args:output:spec.gen

        args:output:spec.fits?(output:splat) then
          # If there are no semantics to satisfy, just return this output
          semantics or return output:splat
          
          rec = args:receiver:spec.gen

          args:receiver:spec.fits?(rec) then 
            # Otherwise, we need to continue generating until we
            # find a receiver and output which satisfy the semantics.
            semantics(rec, input, output) then
              # Woohoo! modify self to reflect the generated receiver
              self:spec.modify!(rec)

              # Return the generated output
              return output:splat
            end
          end
        end
      end
    end

    args:message:put!(receiver, message.gen)

    return args:message
  end

  def spec.check[message.predicate]
    loop
      receiver = args:receiver:spec.gen
      ..input  = args:input:spec.gen
      ..output = receiver:send(args:message, input:splat)

      yield message.predicate(receiver, input, output)
    end
  end

  return message.predicate
end

# A default gen implementation is the identity function
def spec.gen []; self end

## FITS
# Default fits? specializfation is just good ol' equality
def spec.fits?      [](value); self == value    end
# Since a spec is just a predicate, we can simply call it and return the result
def spec.fits?[.Block](value); self(value)      end

## MODIFY
# Because it is common for gab messages to modify `self`, spec
# needs a way to emulate this in generated methods.
def spec.modify![.Record](new_value)
  for k in self:keys
    # If new_value has a corresponding value, modify self. Else, pass
    _, v = new_value:at(k) in match
      .some => self[k] = v end
      else  => .pass       end
  end
end

return nil
