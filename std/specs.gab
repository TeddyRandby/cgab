:use 'maps'
:use 'records'
:use 'lists'
:use 'any'
:use 'symbol'

def spec.invalid = :symbol.new('spec.invalid')

## Registry of qualified name -> spec
def registry.spec = :map.new

## Registry of qualified name -> help text
def registry.help = :map.new

def register(registry, name, value)
  # Add a new specification to the registry.
  # If this key already existed, panic.
  result = registry:add!(name, value) in match
     .ok  => .pass                  end
     else => .SPEC_NAME_TAKEN:panic end
end

## Add a spec to the global registry under the given name.
def spec.def[](name, spec)
  ?spec match
    ?{ spec } => 
      register(registry.spec, name, spec:spec)
    end
    ?{ spec help } => 
      register(registry.spec, name, spec:spec)
      register(registry.help, name, spec:help)
    end
    else => register(registry.spec, name, spec) end
end

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

def spec.int[]
  def int.predicate(value)
    return value:is_n?, self, value
  end

  def spec.gen[int.predicate]; :int.between(-10000, 10000) end

  return int.predicate
end

def spec.float[]
  def float.predicate(value)
    return value:is_n?, self, value
  end
  
  def spec.gen[float.predicate]; :float.between(-10000, 10000) end

  return float.predicate
end

def spec.string[]
  def string.predicate(value)
    return value:is_s?, self, value
  end

  def spec.gen[string.predicate]
    def len  = :int.between(1, 100)
    def list = :list.new
    
    i = 0
    
    loop
      list:push!(:int.between(0, 127))
      i = i + 1
    until i == len end
    
    list:to_bytes
  end

  return string.predicate
end

def spec.gt[](min)
  def gt.predicate(value)
    return value > min, self, value
  end
end

def spec.lt[](min)
  def lt.predicate(value)
    return value < min, self, value
  end
end

## predicate for a map of key type -> value type
def spec.map[](k_spec, v_spec)
  def map.predicate (value)
    ?value == .Map or return false, self, value 
    
    for k, v in value:each
      k_spec:spec.fits?(k) or return false, k_spec, k, k
      v_spec:spec.fits?(v) or return false, v_spec, v, k
    end

    return true, self, value
  end

  def spec.gen[map.predicate]
    :map.new { [k_spec:spec.gen] = v_spec:spec.gen }
  end

  return map.predicate
end

## predicate for a list of values
def spec.list[](spec)
  def list.predicate (value)
    ?value == .List or return false, self, value

    for v, i in value:each
      spec:spec.fits?(v) or return false, self, value, i
    end

    return true, self, value
  end

  def spec.gen[list.predicate]
    :list.new:push!(spec:spec.gen)
  end

  return list.predicate
end

## predicate for a list of keys
def spec.record[](record)
  # Return a predicate which returns true if the given value
  # has all the keys of the record
  def record.predicate (value)
    ## TODO: Update this such that the value is AT LEAST the record
    value:is?(record) or return false, self, value

    for k in :record.new(record):each
      # If the value has the shape we expect,
      # then we can continue on and check each
      # of its keys against a possible spec
      # in the registry.
      _, spec = registry.spec:at(k) in match
         .some => spec:spec.fits?(value:at(k)) else
              return false, spec, value, k
            end
         end
         else  => .MISSING_SPEC:panic end
    end

    return true, self, value
  end

  def spec.gen[record.predicate]
    gen = :record.new(record)

    for k in :record.new(record):each
      _, spec = registry.spec:at(k) in match
        .some =>
          gen[k] = spec:spec.gen
        end
        else  => .MISSING_SPEC:panic        end
    end

    return gen
  end

  return record.predicate
end

def spec.or[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  def or.predicate (value)
    for k, spec in specs:each
      spec:spec.fits?(value) and return true, spec, value, k
    end
    
    return false, nil, value
  end

  def spec.gen[or.predicate]
    specs:at(:int.between(0, specs:len - 1)):spec.gen
  end

  return or.predicate
end

def spec.and[](..specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  def and.predicate (value)
    for k, spec in specs:each
      spec:spec.fits?(value) or return false, spec, value, k
    end
    
    return true, self, value
  end
  
  def spec.gen[and.predicate]
    tries = 0
    
    loop
      value, valid, tries = specs:at(0):spec.gen, false, tries + 1

      results = (specs:at(0)):spec.fits?(value)

      for _, spec in specs:each
        valid = spec:spec.fits?(value)
        valid or break
      end

    valid and return value

    until tries == 100 end

    .SPEC_COULD_NOT_GEN:panic
  end

  return and.predicate
end

def spec.fn.Args { message input output }

def spec.fn.predicate(args, semantics)
  def fn.predicate(before)
    generated_input = args:input:spec.gen
    
    success, pred, after, path = args:output:spec.fits?(before:send(args:message, generated_input))

    # If we don't have a semantic checker, just return the results of the output spec
    # If we didn't succeed in parsing the result, no point in checking semantics
    semantics and success or return success, self, generated_input, path

    return semantics(before, after, generated_input), self, generated_input
    
  end
end

def spec.block[](args, semantics)
  args:is?(spec.fn.Args) or .INVALID_ARGUMENTS:panic

  def pred = spec.fn.predicate(args, semantics)
  
  return pred
end

def spec.message[](args, semantics)
  args:is?(spec.fn.Args) or .INVALID_ARGUMENTS:panic

  def pred = spec.fn.predicate(args, semantics)

  def spec.check[pred](receiver_spec, i)
    iterations = i or 100

    iterations:times do
      receiver = receiver_spec:spec.gen

      receiver_spec:spec.fits?(receiver) then
        success = pred(receiver)

        success or 'SPEC_CHECK_FAILED':panic
      end
    end
  end

  return pred
end

# A default gen implementation is the identity function
def spec.gen []; self end

## FITS
# Default fits? specializfation is just good ol' equality
def spec.fits?      [](value); self == value    end
# Since a spec is just a predicate, we can simply call it and return the result
def spec.fits?[.Block](value); self(value)      end

return nil
