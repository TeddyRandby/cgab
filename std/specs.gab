:use .maps
:use .records
:use .lists
:use .shapes
:use .symbol
:use .numbers
:use .msg
:use .any
:use .streams

## TODO: Optimize for memory by caching generated specs based on input

## Registry of qualified name -> spec
def registry.spec = :map.new

## Registry of qualified name -> help text
def registry.help = :map.new

def register(registry, name, value)
  # Add a new specification to the registry.
  # If this key already existed, panic.
  registry:add!(name, value) == .ok or .SPEC_NAME_TAKEN:panic
end

## Add a spec to the global registry under the given name.
def spec.def![](name, opts)
  register(registry.spec, name, opts:spec)
end

def spec.help[](name)
  registry.help:at(name)
end

def spec[](name)
  _, s = registry.spec:at(name) in == .ok or .MISSING_SPEC:panic
end

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

def spec.nil[]
  def nil.predicate(value)
    return not value, self, value
  end
end

def spec.unknown[]
  def unknown.predicate(value)
    return true, self, value
  end
end

def spec.int[]
  def int.predicate(value)
    return value:is_n?, self, value
  end

  def spec.gen[int.predicate]; :int.between(-10000, 10000) end

  return int.predicate
end

def spec.float[]
  def float.predicate(value)
    return value:is_n?, self, value
  end
  
  def spec.gen[float.predicate]; :float.between(-10000, 10000) end

  return float.predicate
end

def spec.string[]
  def string.predicate(value)
    return value:is_s?, self, value
  end

  def spec.gen[string.predicate]
    def len  = :int.between(1, 100)
    def list = :list.new
    
    i = 0
    
    loop
      list:push!(:int.between(0, 127))
      i = i + 1
    until i == len end
    
    list:to_bytes
  end

  return string.predicate
end

def spec.bool[]
  def bool.predicate(value)
    return value:is_b?, self, value
  end

  def spec.gen[bool.predicate]
    :float.between > 0.5
  end

  return bool.predicate
end

## predicate for a map of key type -> value type
def spec.map[](k_spec, v_spec)
  def map.predicate (value)
    ?value == .Map or return false, self, value 
    
    value:for(&:pairs) do (k, v)
      k_spec:spec.fits?(k) or return false, k_spec, k, k
      v_spec:spec.fits?(v) or return false, v_spec, v, k
    end

    return true, self, value
  end

  def spec.gen[map.predicate]
    :map.new { [k_spec:spec.gen]:  v_spec:spec.gen }
  end

  return map.predicate
end

## predicate for a list of values
def spec.list[](spec)
  def list.predicate (value)
    ?value == .List or return false, self, value

    value:for(&:pairs) do (k, v)
      spec:spec.fits?(v) or return false, self, value, k
    end

    return true, self, value
  end

  def spec.gen[list.predicate]
    :list.new:push!(spec:spec.gen)
  end

  return list.predicate
end

## predicate for a type which implements a set of messages
def spec.protocol[](protocol)
  # Return a predicate which returns true if the given value
  # has all the keys of the record
  def protocol.predicate (value)
    protocol:for(&:keys) do (k)
      # If message doesn't specify for this value, then the spec doesn't fit
      m = :message.new(k)
      m:has?(value) or return false, self, k

      # Check for a spec which corresponds to this message in the protocol
      res, s = registry.spec:at(k)
      
      res == .some and s:spec.fits?(value[k]) else
        return false, s, value, k
      end

    end

    return true, self, value
  end

  def spec.gen[protocol.predicate]
    def gen = :record.new(protocol)

    protocol:for(&:keys) do (k)
      _, s = registry.spec:at(k) in match
        .some => gen[k] = s:spec.gen end
        else  => .MISSING_SPEC:panic end
    end

    return gen
  end

  return protocol.predicate
end

## Convenience specs for composing above types
def spec.tuple[](*specs); :spec.record(specs) end

def spec.result[](value, err)
  :spec.or(
    :spec.tuple(.ok, value),
    err,
  )
end

def spec.option[](value)
  :spec.or(
    :spec.tuple(.some, value),
    .none,
  )
end

def spec.or[](*specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  def or.predicate (value)
    specs:fold(&:pairs, false) do (acc, k, spec)
      { k spec value }:print
      spec:spec.fits?(value) or acc
    end
    
    return false, self, value
  end

  def spec.gen[or.predicate]
    specs[(:int.between(0, specs:len - 1))] :spec.gen
  end

  return or.predicate
end

def spec.and[](*specs)
  specs:len > 0 or .INVALID_ARGUMENTS:panic
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  def and.predicate (value)
    specs:for(&:pairs) do (k, spec)
      spec:spec.fits?(value) or return false, spec, value, k
    end
    
    return true, self, value
  end
  
  def spec.gen[and.predicate]
    tries = 0
    
    start = specs[0]
    loop
      def value = start:spec.gen
      tries = tries + 1

      valid = specs:fold(&:values, true) do (a, s)
        a and s:spec.fits?(value)
      end

      valid and return value

    until tries == 100 end

    .SPEC_COULD_NOT_GEN:panic
  end

  return and.predicate
end

# Modifying specs
def spec.gt[](min)
  def gt.predicate(value)
    return value > min, self, value
  end
end

def spec.lt[](min)
  def lt.predicate(value)
    return value < min, self, value
  end
end

def spec.block.Args { input output }

def spec.block[](args, semantics)
  args:is?(spec.block.Args) or .INVALID_ARGUMENTS:panic

  def block.predicate(input, output)
    success, pred, val, path = args:input:spec.fits?(input:splat)
    success or return false, pred, input, .input
    
    success, pred, val, path = args:output:spec.fits?(output:splat)
    success or return false, pred, output, .output

    semantics or return success, self, [input, output]

    return semantics(input, output), self, [input, output], .semantics
  end

  def spec.gen[block.predicate]
    def block.gen(*input)
      loop
        # Generate an output
        *output = args:output:spec.gen

        args:output:spec.fits?(output:splat) then
          # If there are no semantics to satisfy, just return this output
          semantics or return output:splat
          
          # Otherwise, we need to continue generating until we
          # find an output which satisfy the semantics for the input.
          semantics(input, output) and return output:splat
        end
      end
    end
  end

  def spec.check[block.predicate](block)
    loop
      *input  = args:input:spec.gen

      args:input:spec.fits?(input:splat) then
        *output = block(input:splat)
        
        yield block.predicate(input, output)
      end
    end
  end
  
  return block.predicate
end

## TODO: Handle -
##    - no arguments
##    - no output
##    - no receiver
def spec.message.Args { message receiver input output }

def spec.message[](args, semantics)
  args:is?(spec.message.Args) or .INVALID_ARGUMENTS:panic

  def message.predicate(rec, input, output)
    success, pred, val, path = args:input:spec.fits?(input:splat)
    success or return false, pred, input, .input
    
    success, pred, val, path = args:output:spec.fits?(output:splat)
    success or return false, pred, output, .output
    
    success, pred, val, path = args:receiver:spec.fits?(rec)
    success or return false, pred, rec, .receiver
    
    semantics or return success, self, [rec, input, output]

    return semantics(rec, input, output), self, [rec, input, output], .semantics
  end

  def spec.gen[message.predicate](receiver)
    def message.gen(*input)
      args:input:spec.fits?(input:splat) or .INVALID_ARGUMENTS:panic

      loop
        # Generate an output
        *output = args:output:spec.gen

        args:output:spec.fits?(output:splat) then
          # If there are no semantics to satisfy, just return this output
          semantics or return output:splat
          
          rec = args:receiver:spec.gen

          args:receiver:spec.fits?(rec) then 
            # Otherwise, we need to continue generating until we
            # find a receiver and output which satisfy the semantics.
            semantics(rec, input, output) then
              # Woohoo! modify self to reflect the generated receiver
              self:spec.modify!(rec)

              # Return the generated output
              return output:splat
            end
          end
        end
      end
    end
    
    args:message:put!(receiver, message.gen)

    return args:message
  end

  def spec.check[message.predicate]
    loop
      receiver = args:receiver:spec.gen

      { receiver }:print

      args:receiver:spec.fits?(receiver) then
        *input  = args:input:spec.gen

        { input arg: args:input }:print

        args:input:spec.fits?(input:splat) then
          *output = receiver:(args:message)(input:splat)
          
          yield message.predicate(receiver, input, output)
        end
      end
    end
  end

  return message.predicate
end

# A default gen implementation is the identity function
def spec.gen []; self end

## FITS
# Default fits? specializfation is just good ol' equality
def spec.fits?      [](value); self == value    end
# Since a spec is just a predicate, we can simply call it and return the result
def spec.fits?[.Block](value); self(value)      end

## MODIFY
# Because it is common for messages to modify `self`, spec
# needs a way to emulate this in messages that it generates.
# User types can define their own version of &:spec.modify! If this
# Doesn't satisfy their use case.
def spec.modify![.Record](new_value)
    self:for(&:keys) do (k)
    # If new_value has a corresponding value, modify self. Else, pass
    _, v = new_value:at(k) in match
      .some => self[k] = v end
      else  => .pass       end
  end
end

return nil
