maps.t = 'maps':use
records.t = 'records':use
lists.t = 'lists':use

'shapes':use
'symbol':use
'numbers':use
'msg':use
'any':use
'assert':use
'monads':use

explain_specs = do specs, separator
  specs:tuple.collect(
        \map,
        \values,
        \spec.explain,
        specs:len,
      ):join(
        \values,
        separator,
        \+,
      )
end

explain_strings = do strings, separator
  strings:tuple.collect(
          \map,
          \values,
          do v; '{v} = {v:spec:spec.explain}' end,
          strings:len,
        ):join(
          \values,
          separator,
          \+,
        )
end

## Registry of qualified name -> spec
registry.spec = maps.t :make

## Registry of spec -> qualified name
registry.name = maps.t :make

## Registry of qualified name -> help text
registry.help = maps.t :make

## Registry of receiver -> list of spec'd messages
registry.messages = maps.t :make

register! = do registry, name, value
  # Add a new specification to the registry.
  # If this key already existed, panic.
  registry:add!(name, value):unwrap!
end


\spec.register! :defcase! {
  [{ spec }?] = do name
    register!(registry.spec, name, self:spec)
    register!(registry.name, self:spec, name)

    self:spec
  end,
  [{ spec, help }?] = do name
    register!(registry.spec, name, self:spec)
    register!(registry.name, self:spec, name)
    register!(registry.help, self:spec, self:help)

    self:spec
  end,
}

## Add a spec to the global registry under the given name.
\def.spec! :def! ([], do name, opts
  opts:spec.register(name)
end)

\spec :def! ([], do name
  registry.spec:at(name):unwrap!
end)

\spec.help :def! ([], do
  registry.help:at(self)
end)

\spec.name :def! ([], do
  registry.name:at(self):unwrap!
end)

## PREDICATES
# A spec predicate is a function which:
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

# NIL PREDICATE
nil.predicate = .predicate.nil

\spec.fits? :def! ([nil.predicate], do value
  (value == .nil, self, value)
end)

\spec.gen :def! ([nil.predicate], do
  .nil
end)

\spec.explain :def! ([nil.predicate], 'Nil')

\spec.nil :def! ([], nil.predicate)

# UNKNOWN PREDICATE
unknown.predicate = .predicate.unknown

\spec.fits? :def! ([unknown.predicate], do value
  (.true, self, value)
end)

unknown_values = [ .nil, 0, 1, 'test', .true ]

\spec.gen :def! ([unknown.predicate], do
  idx = .int:between(0, unknown_values:len - 1)

  unknown_values:at!(idx)
end)

\spec.explain :def! ([unknown.predicate], 'Unknown')

\spec.unknown :def! ([], unknown.predicate)

registry.name:put!(unknown.predicate, 'unknown')

# INT PREDICATE
int.predicate = .predicate.int

\spec.fits? :def! ([int.predicate], do value
  (value:is_n?, self, value)
end)

\spec.gen :def! ([int.predicate], do
  .int:between(-10000, 10000)
end)

\spec.explain :def! ([int.predicate], 'Int')

\spec.int :def! ([], int.predicate)

#
# FLOAT PREDICATE
#

float.predicate = .predicate.float

\spec.fits? :def! ([float.predicate], do value
  (value:is_n?, self, value)
end)

\spec.gen :def! ([float.predicate], do
  .float:between(-10000, 10000)
end)

\spec.explain :def! ([float.predicate], 'Float')

\spec.float :def! ([], float.predicate)

#
# STRING PREDICATE
#
string.predicate = .predicate.string

\spec.fits? :def! ([string.predicate], do value
  (value:is_s?, self, value)
end)

\spec.gen :def! ([string.predicate], do
  len  = .int:between(1, 100)
  list = lists.t :make

  len:times => list:push!(.int:between(0, 127))
  
  list:to_bytes
end)

\spec.explain :def! ([string.predicate], 'String')

\spec.string :def! ([], string.predicate)

#
# SHAPE PREDICATE
#

shape.predicate = .predicate.shape

\spec.fits? :def! ([shape.predicate], do value
  (value:is_shape?, self, value)
end)

\spec.gen :def! ([shape.predicate], do
  { a, b, c }?
end)

\spec.explain :def! ([shape.predicate], 'Shape')

\spec.shape :def! ([], shape.predicate)

#
# BOOL PREDICATE
#
boolean.predicate = .predicate.boolean

\spec.fits? :def! ([boolean.predicate], do value
  (value:is_b?, self, value)
end)

\spec.gen :def! ([boolean.predicate], do
  .float:between > 0.5
end)

\spec.explain :def! ([boolean.predicate], 'Boolean')

\spec.boolean :def! ([], boolean.predicate)

\spec.recursively :defcase! {
  # In the boolean cases, recurse if the spec matched
  # and bail early if it didn't
  .true = do tail, curr, alt
    tail:spec.recursively(alt**)
  end,
  .false = do tail, curr, alt
    (self, curr**)
  end,
  # In the recursion cases, continue to check head 
  # until there is no tail
  .nil = do alt[]
    alt**
  end,
  [records.t] = do alt[]
    spec, value = self:head**

    does_fit, result[] = spec :spec.fits? value

    does_fit :spec.recursively (self:tail, result, alt)
  end,
}

## predicate for a map of key type -> value type
\spec.map :def! ([], do k_spec, v_spec
  map.predicate = 'predicate:map:{k_spec}:{v_spec}' :sigil.into

  \spec.fits?:def! ([map.predicate], do value
    (value ? == maps.t) :and do
      (.false, self, value)
    end :or do
      value :for(
        \pairs,
        do k, v
          [ [k_spec, k], [v_spec, v] ] :spec.recursively
        end,
        )

       (.true, self, value)
    end
  end)

  \spec.gen :def! ([map.predicate], do
    maps.t :make { [k_spec:spec.gen] =  v_spec:spec.gen }
  end)

  \spec.explain :def! ([map.predicate], do
    'Map[{k_spec:spec.explain}: {v_spec:spec.explain}]'
  end)

  map.predicate
end)

## predicate for a list of values
\spec.list :def! ([], do spec
  list.predicate = 'predicate:list:{spec}' :sigil.into

  \spec.fits? :def! ([list.predicate], do value
    value:spec.fits_each?(\values)
  end)

  \spec.gen :def! ([list.predicate], do
    lists.t:make:push!(spec:spec.gen)
  end)

  \spec.explain :def! ([list.predicate], do
    'list[{spec:spec.explain}]'
  end)

  list.predicate
end)

## predicate for a type which implements a set of messages
\spec.protocol :def! ([], do protocol
  protocol.predicate = 'predicate:protocol:{protocol}' :sigil.into
# Return a predicate which returns true if the given value
# has all the keys of the record
  \spec.fits? :def! ([protocol.predicate], do value
    protocol:spec.fits_each?(\keys, do k
# If message doesn't specify for this value, then the spec doesn't fit
      m = .gab.message :make k

# Check for a spec which corresponds to this message in the protocol
      m:has?(value) :and (.false, self, k, do
       registry.spec:at(k) :unwrap:and (.false, self, value, k, do res, s
          s:spec.fits?(value[k])
        end)
      end)

      (.true, self, value)
    end)
  end)

  \spec.gen :def! ([protocol.predicate], do
    gen = records.t :make protocol

    protocol:for(\keys, do k
      found = registry.spec:at!(k)

      gen:put!(k, found:spec.gen)
    end)

    gen
  end)

  \spec.explain :def! ([protocol.predicate], do
    protocol:len == 0 :or "{}" =>
      "{\n " + explain_strings(protocol, '\n ') + "\n}"
  end)

  protocol.predicate
end)

\spec.values :def! ([], do specs[]
  values.predicate = 'predicate:values:{specs}' :sigil.into

  \spec.fits? :def! ([values.predicate], do values[]
     specs:reduce(
              \pairs,
              [ .true, values.predicate, values, .nil ],
              do a, i, s
                # Stop at the first failing spec
                # a[0] or a

                success, sp, value, path = s:spec.fits?(values[i])

                # If our spec fits, continue with the initial value.
                # Otherwise, return the result from the failed spec
                success :and([success, sp, value, path], a)
              end,
         )**
  end)

  \spec.gen :def! ([values.predicate], do
    res = .gab.tuple:make(specs:len)

    res:map! do k
      specs:at!(k):spec.gen
    end

    res
  end)

  \spec.explain :def!([values.predicate], do
    explain_specs(specs, ', ')
  end)

  values.predicate
end)

## Convenience specs for composing above types
\spec.result :def! ([], do value, err
  .spec:or(
    .spec:values(.ok, value),
    err,
  )
end)

\spec.option :def! ([], do value
  .spec:or(
    .spec:values(.ok, value),
    .none,
  )
end)

\spec.or :def! ([], do specs[]
  specs:len > 0 :or => .INVALID_ARGUMENTS:panic
  
  or.predicate = 'predicate:or:{specs}' :sigil.into
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  \spec.fits? :def! ([or.predicate], do value
    valid = specs:fold(\values, .false) do acc, s
      acc :or => s:spec.fits?(value)
    end
    
    (valid, self, value)
  end)

  \spec.gen :def! ([or.predicate], do
    specs:at!(.int:between(0, specs:len - 1)) :spec.gen
  end)

  \spec.explain :def! ([or.predicate], do
    explain_specs(specs, ' | ')
  end)

   or.predicate
end)

\spec.and :def! ([], do specs[]
  specs:len > 0 :or => .INVALID_ARGUMENTS:panic

  and.predicate = 'predicate:and:{specs}' :sigil.into
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  \spec.fits? :def! ([and.predicate], do value
    specs:for(\pairs, do k, spec
      spec:spec.fits?(value) :or => (.false, spec, value, k)
    end)
    
    (.true, self, value)
  end)
  
  \spec.gen :def! ([and.predicate], do
    start = specs[0]

    100:first(\upto, do
      value = start:spec.gen

      specs:fold(\values, .true, do a, s
        a :and => s:spec.fits?(value)
      end)
    end):unwrap!
  end)

  \spec.explain :def! ([and.predicate], do
    explain_specs(specs, ' & ')
  end)

   and.predicate
end)

# Modifying specs
\spec.gt :def! ([], do min
  gt.predicate = 'predicate:gt:{min}' :sigil.into

  \spec.fits? :def! ([gt.predicate], do value
    (value > min, self, value)
  end)

  \spec.explain :def!([gt.predicate], '> {min}')

  gt.predicate
end)

\spec.lt :def! ([], do max
  lt.predicate = 'predicate:lt:{max}' :sigil.into

  \spec.fits? :def ([lt.predicate], do value
    (value < max, self, value)
  end)

  \spec.explain :def! ([lt.predicate], '< {max}')

  lt.predicate
end)

spec.block.Args = { input, output, semantics }

spec.block.Application = spec.block.Args :with .in :with .out

\spec.block.input_fits? :def! ([spec.block.Application], do
  self:input:spec.fits?(..(self:in))
end)

\spec.block.output_fits? :def! ([spec.block.Application], do
  self:output:spec.fits?(..(self:out))
end)

\spec.semantic_fits? :def! ([.nil], do input, output
  (.true, .nil, [input, output])
end)

\spec.semantics_fits? :def! ([.gab.block], do input, output
  (self(input, output), self, [input, output], .semantics)
end)

\spec.block.semantics_fits? :def! ([spec.block.Application], do input, output
  self:at!(.semantics):spec.semantic_fits?(input, output)
end)

\spec.block :def! ([], do args, semantics
  args:assert.is?(spec.block.Args)

  block.predicate = 'predicate:block:{args}:{semantics}' :sigil.into

  \spec.fits? :def! ([block.predicate], do input, output
    v = args:with(.input_value, input):with(.output_value, output)

    v:first(
      \apply,
      [
        \spec.block.input_fits?,
        \spec.block.output_fits?,
        \spec.semantic_fits?,
      ],
      \option.into,
    )
  end)

  \spec.gen :def! ([block.predicate], do
    block.gen = do input[]
      100:first(\upto, do
        # Generate an output
        output[] = args:output:spec.gen

        v = args:with(.input_value, input):with(.output_value, output)

        v:first(
          \apply,
          [
            \spec.block.input_fits?,
            \spec.block.output_fits?,
            \spec.semantic_fits?,
          ],
          \option.into,
        )
      end):unwrap!
    end
  end)

  \spec.check :def! ([block.predicate], do block
    100:first(\upto, do
      input[]  = args:input:spec.gen

      args:input:spec.fits?(input**) :and do
        output[] = block(input**)
        
        (.some, block.predicate(input, output))
      end
    end)
  end)
  
  block.predicate
end)

general_message.predicate = 'predicate:message' :sigil.into

\spec.fits? :def! ([general_message.predicate], do value
  (value:is_m?, self, value)
end)

\spec.gen :def! ([general_message.predicate], \+)

\spec.explain :def! ([general_message.predicate], 'Message')

## TODO: Handle -
##    - no arguments
##    - no output
##    - no receiver
spec.message.Args = { receiver, message, input, output }

spec.message.Application = spec.message.Args :with .in :with .out :with .rec

\spec.message.input_fits? :def! ([spec.message.Application], do
  self:input:spec.fits?(self:in**)
end)

\spec.message.output_fits? :def! ([spec.message.Application], do
  self:output:spec.fits?(self:out**)
end)

\spec.message.receiver_fits? :def! ([spec.message.Application], do
  self:receiver:spec.fits?(self:rec**)
end)

\spec.message.semantics_fits? :def! ([spec.message.Application], do input, output
  self:at!(.semantics):spec.semantic_fits?(input, output)
end)

\spec.message.define :def! ([.nil], general_message.predicate)


\spec.message :def! ([], do args, semantics
  args:spec.message.define(args, semantics)
end)

LabeledSpec = { spec.label, spec.spec }

\spec.label :def! ([], do spec.spec, spec.label
  { spec.label, spec.spec }
end)

\spec.explain :def! ([LabeledSpec ?], do
  '{self:spec.label}: {self:spec.spec:spec.explain}'
end)

LabeledSpec:deferto(
  \spec.gen,
  \spec.fits?,
  \spec.check,
  \spec.modify!,
  \spec.spec,
)

# A default gen implementation is the identity function
\spec.gen :def! ([], do; self end)

# A default explain implementation
\spec.explain :def! ([], do; '{self}' end)

\spec.doc :def! ([], do
  name, help = registry.name:at!(self), registry.help:at!(self)

  '## {name}\n{help}\n\n\t{self:spec.explain}\n'
end)

\spec.messages :def! ([], do
  registry.messages:at(self):unwrap:and do a
    a:for(\map, \values, \spec.doc, \print)
  end
end)

## FITS
# Default spec.fits? specializfation is just good ol' equality
\spec.fits? :def! ([], do value
  (self == value, self, value)
end)

# Since a spec is just a predicate, we can simply call it and return the result
\spec.fits? :def! ([.gab.block], do value; self(value) end)

## MODIFY
# Because it is common for messages to modify `self`, spec
# needs a way to emulate this in messages that it generates.
# User types can define their own version of &:spec.modify! If this
# Doesn't satisfy their use case.
\spec.modify! :def! ([.gab.record], do new_value
    self:for(\keys, do k
      # If new_value has a corresponding value, modify self. Else, pass
      v = new_value:at(k):unwrap:and do other
        self:at!(k) = other
      end
  end)
end)
