require('list')

impl $List
  def [](key)
    ?key match
      ?{ from to }     => self:slice(key.from, key.to)        end
      ?{ from }        => self:slice(key.from)                end
      ?{ to }          => self:slice(0, key.to)               end
      $Number          => self:at(key)                        end
      else             => panic($INVALID_ARGUMENTS)   end
  end

  def [=](key, value)
    self:put(key, value)
  end

  def first
    self:at(0)
  end

  def last
    self:at(self:len - 1)
  end

  def take(to)
    self:slice(0, to)
  end

  def each
    self:len == 0 and return

    let v = 0 

    loop
      yield self:at(v), v
      v = v + 1
    until v >= self:len
  end

  def fold(init, folder)
    let v = init

    for i, index in self:each
        v = folder(v, i, index)
    end

    v
  end

  def filter(filterer)
    let v = :list

    for i, index in self:each
        filterer(i, index) and v:push(i)
    end

    v
  end

  def map(mapper)
    let v = :list

    for i, index in self:each
        v:push(mapper(i, index))
    end

    v
  end

  def fill(value)
    let v = :list

    for _, index in self:each
        self:put(index, value)
    end

    v
  end

  def map!(mapper)
      for i, index in self:each
          self:put(index, mapper(i, index))
      end

      self
  end


  def fill!(value)
      for _, index in self:each
        self:put(index, value)
      end

      self
  end

  def compact
    self:filter do (i) not i == nil end
  end

  def join(sep)
    self:fold('') do (str, cur, i)
      i == 0 and '{cur}' or str + sep + '{cur}'
    end
  end

  def every?(pred)
    for i, _ in self:each
      pred(i) or return false
    end

    true
  end

  def some?(pred)
    for i, _ in self:each
      pred(i) and return true
    end

    false
  end

  def empty? self:len > 0 end

  def include?(value)
      for i, _ in self:each
          i == value and return true
      end

      false
  end

  def collect!(..args)
    for ..all in args:splat
        self:push(all:splat)
    end

    self
  end

end



