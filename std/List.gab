def __get__[List](key)
    key:type match
        { from to }:type => self:slice(key.from, key.to)
        { from }:type    => self:slice(key.from)
        { to }:type       => self:slice(nil, key.to)
        Number           => self:at(key)
        else             => panic('Invalid call to List::key')
end

def __set__[List](key, value) self:put(key, value) end

def first[List] self[0] end

def last[List] self[self:len - 1] end

def take[List](amount) self[amount:to] end

def each[List]
    let v = 0 

    loop
       yield self[v], v
       v = v + 1
    until v >= self:len
end

def fold[List](init, folder)
    let v = init

    for i, index in self:each
        v = folder(v, i, index)
    end

    v
end

def filter[List](filterer)
    let v = []

    for i, index in self:each
        filterer(i, index) and v:push(i)
    end

    v
end

def map[List](mapper)
    let v = []

    for i, index in self:each
        v:push(mapper(i, index))
    end

    v
end

def join[List](sep)
  self:fold('', do (str, cur, i)
    i == 0 then
      String:from(cur)
    end else
      str + sep + String:from(cur)
    end
  end)
end

def every?[List](pred) self:filter(pred):len == self:len end

def some?[List](pred) self:filter(pred):len > 0 end

def empty?[List] self:len > 0 end

def include?[List](value)
    for i, index in self:each
        i == value and return true
    end

    false
end
