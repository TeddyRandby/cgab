module = .gab.iter

\iter.apply:def!(
  .none .nil
  x => x)

\defiter!:def!(
  'gab.message'
  (cx init) => do
    mod.t = {
      module .nil
      self .nil
      \state init
      \continuation .none
      \reducer .nil
    }

    self:def!(
      module
      (xs[]) => mod.t:reducer(cx:(xs**)))

    [mod.t ?] :defmodule! {
      \|> iter => self:iter.compose iter

      \iter.compose second => self:iter.apply second

      \iter.apply c => self:continuation(self:continuation:iter.apply c)

      \reduce.step (acc xs[]) => do
        (s cmd c acc) = self:reducer:(self:continuation, acc xs self:state)

        (cmd self:continuation c :state s acc)
     end

      \reduce.done (acc) => self:continuation:reduce.done acc
    }
  end)

\iter.conditionally :defcase! {
  .true (r acc xs s) => (s r:reduce.step(acc xs**))
  .false (r acc xs s) => (s .next r acc)
}

\iter.stop_conditionally_inclusive :defcase! {
  .true (r acc xs s) => (s r:reduce.step(acc xs**))
  .false (r acc xs s) => do
    (cmd r acc) = r:reduce.step(acc xs**)
    (s .stop r acc)
  end
}

\iter.stop_conditionally :defcase! {
  .true (r, acc, xs, s) => (s, r:reduce.step(acc, xs**)),
  .false (r, acc, xs, s) => (s, .stop, r, acc),
}

\map:defiter!(
  f => (r acc xs) => (.nil r:reduce.step(acc f:(xs**))))

\tap:defiter!(
  f => do
    (r acc xs) => do
      f:(xs**)
      (.nil r:reduce.step(acc xs**))
    end
  end)

\filter:defiter!(f => do
  (r acc xs) => do
    f:(xs**):iter.conditionally(r acc xs)
  end
end)

\take :defiter! (n => do
  (r, acc, xs, nth) => do
    nxth = nth + 1
    (nxth < n):iter.stop_conditionally_inclusive(r, acc, xs, nxth)
  end
end, 0)


\take_while :defiter! (f => do
  (r, acc, xs) => f:(xs**):iter.stop_conditionally(r, acc, xs)
end)

\drop :defiter! (n => do
  (r, acc, xs, nth) => do
    (nth >= n):iter.conditionally(r, acc, xs, nth + 1)
  end
end, 0)

\iter.do_dropwhile :defcase! {
  .true (r, acc, xs, b, f) => (.true, r:reduce.step(acc, xs**))
  .false (r, acc, xs, b, f) => do
    new_b = b | (f:(xs**)) !
    new_b:iter.conditionally(r, acc, xs, new_b)
  end
}

\drop_while :defiter! (f => do
  (r, acc, xs, b) => b:iter.do_dropwhile(r, acc, xs, b, f)
end, .false)

\iter.do_interpose :defcase! {
  .next (r, acc, xs) => (.true, r:reduce.step(acc, xs**))
  .stop (r, acc, xs) => (.true, .stop, r, acc)
  .true (r, acc, xs, sep) => do
    (cmd, r, acc) = r:reduce.step(acc, sep)
    cmd:iter.do_interpose(r, acc, xs)
  end
  .false (r, acc, xs) => (.true, r:reduce.step(acc, xs**))
}

\interpose :defiter! (sep => do
  (r, acc, xs, started) => started:iter.do_interpose(r,acc,xs,sep)
end, .false)

module
