i = 'iter' :use
spec.t = .gab.spec

explain_specs = (specs separator) => specs
  :transduce(
    ''
    \+
    i:map \spec.explain
    |> i:interpose separator)

explain_keys = (strings separator) => strings
  :transduce(
    ''
    \+
    i:map \first
    |> i:map \strings.into
    |> i:interpose separator)

\defspec!:def!(
  'gab.sigil'
  (opts) => do
    \spec.help:def!(
      opts:spec
      () => (opts:at \help))

    \spec.name:def!(
      opts:spec
      self:strings.into)

    \spec:def!(
      self
      opts:spec)

    self
  end)

['gab.sigil'] :defmodule! {
  \spec.doc!     () => (self:spec.help!, self:spec.explain!)
  \spec.help!    () => self:spec:unwrap!:spec.help:unwrap!
  \spec.gen!     () => self:spec:unwrap!:spec.gen
  \spec.explain! () => self:spec:unwrap!:spec.explain
}

## PREDICATES
# A spec predicate is a function which
#   - Takes a value as input
#   - returns (true, spec, value, path) if the value fits the spec,
#      where spec is the spec that accepted the value
#      where value is the accepted value
#      where path is the 'path' taken to the accepted value ( or nil, if no path )
#   - returns (false, spec, value, path) if the value does not fit the spec,
#      where spec is the predicate that rejected the value ( or nil, if no spec was found )
#      where value is the rejected value
#      where path is the 'path' taken to the rejected value ( or nil, if no path )

# NIL PREDICATE
nil.predicate = .predicate.nil

\spec.fits?:def!(
  nil.predicate
  value => (value == .nil self value))

\spec.gen:def!(
  nil.predicate
  .nil)

\spec.explain:def!(nil.predicate 'nil')

# UNKNOWN PREDICATE
unknown.predicate = .predicate.unknown

\spec.fits?:def!(
  unknown.predicate
  value => (.true self value))

unknown_values = [ .nil 0 1 'test' .true ]

\spec.gen:def!(
  unknown.predicate
  () => do
    idx = .int.between(0 unknown_values:len - 1)
    unknown_values:at! idx
  end)

\spec.explain:def!(unknown.predicate 'unknown')

# INT PREDICATE
int.predicate = .predicate.int

\spec.fits?:def!(
  int.predicate
  value => (value:is_n?, self, value))

\spec.gen:def!(
  int.predicate
  () => .int.between:(-10000 10000))

\spec.explain:def!(int.predicate 'int')

#
# FLOAT PREDICATE
#

float.predicate = .predicate.float

\spec.fits?:def!(
  float.predicate
  (value) => (value:is_n?, self, value))

\spec.gen:def!(
  float.predicate
  () => .float.between:(-10000, 10000))

\spec.explain:def!(float.predicate 'float')

#
# STRING PREDICATE
#
string.predicate = .predicate.string

\spec.fits?:def!(
  string.predicate
  (value) => (value:is_s?, self, value))

random.strings = ['vim-users' 'emacs-users']

\spec.gen:def!(
  string.predicate
  () => do
    idx  = .int.between:(0 random.strings:len - 1)
    random.strings :at! idx
  end)

\spec.explain:def!(string.predicate 'string')

#
# SHAPE PREDICATE
#
shape.predicate = .predicate.shape

\spec.fits?:def!(
  shape.predicate
  (value) => (value:is_shape?, self, value))

\spec.gen:def!(
  shape.predicate
  () => { }?)

\spec.explain:def!(shape.predicate 'shape')

#
# BOOL PREDICATE
#
boolean.predicate = .predicate.boolean

\spec.fits?:def!(
  boolean.predicate
 (value) =>(value:is_b?, self, value))

\spec.gen:def!(
  boolean.predicate
  () => .float.between:() > 0.5)

\spec.explain:def!(boolean.predicate 'boolean')

#
# COMPOSING SPECS
#
and.predicate = (specs[]) => do
  (specs:len > 0):assert! 'Must have at least one spec for the and predicate'

  pred = .gab.string:('predicate:and:' specs):sigils.into
  # Return a predicate which returns true iff the given value
  # fits all of the given specs
  \spec.fits?:def!(
    pred
    value => specs:reduce(
        []
        (acc  spec  key) => [spec:spec.fits?(value) :or (.false spec value key)]))
  
  \spec.gen:def!(
    pred
    () => do
      start = specs :at! 0

      xf = i:map(() => do
            value = start:spec.gen

            fits = specs:reduce(.true, (a _ s) => do
              a:then () => s :spec.fits? value
            end)

            (fits, value)
          end)
          |> i:filter(\self)
          |> i:map(\first)
          |> i:take(1)

      .gab.range
        :(100)
        :transduce(0 \first xf)
        :assert!('Failed to generate a value for {specs}')
    end)

  \spec.explain:def!(
    pred
    () => explain_specs:(specs ' & '))

  pred
end

or.predicate = (specs[]) => do
  (specs:len > 0):assert! "The or predicate expects more than zero specs"
  
  pred = .gab.string:('predicate:or:' specs):sigils.into
  # Return a predicate which returns true if the given value
  # fits any of the given specs
  \spec.fits?:def!(
    pred
    value => do
      valid = specs:reduce(.false (acc s) => do
        acc :else () => s :spec.fits? value
      end)

      (valid self value pred)
    end)

  \spec.gen:def!(
    pred
    () => specs:at!(.int.between:(0 specs:len - 1)):spec.gen)

  \spec.explain:def!(
    pred
    () => explain_specs:(specs ' | '))

  pred
end

values.predicate = (specs[]) => do
  pred = .gab.string:('predicate:values:' specs:sigils.into)

  \spec.fits?:def!(
    pred
    (values[]) => specs:reduce(
            [ .true pred values .nil ]
            (a s i) => do
              # Stop at the first failing spec
              # a[0] or a

              (success sp value path) = s:spec.fits?(values[i])

              # If our spec fits, continue with the initial value.
              # Otherwise, return the result from the failed spec
              success:and([success sp value path] a)
            end)**)

  \spec.gen:def!(
    pred
    () => specs:map \spec.gen)

  \spec.explain:def!(
    pred
    () => '(' + explain_specs:(specs, ', ') + ')')

  pred
end

protocol.predicate = (protocol) => do
  protocol_shape = protocol ?
  pred = .gab.string:('predicate:protocol:' protocol):sigils.into
# Return a predicate which returns true if the given value
# has all the keys of the record
  \spec.fits?:def!(
    pred
    value => do
      protocol:reduce([.true self value] (acc m) => do
# Check for a spec which corresponds to this message in the protocol
        acc:at! 0 :and acc :else () => do
          m :has? value :then () => do
            m:sigils.into:spec:ok?:then s => do
              s:spec.fits?(value :at! m)
            end
          end :or [.false, self, value, m]
        end
      end):**
    end)

  genit = i:map (_ key) => do
    found = key:sigils.into:spec
    (key found:spec.gen)
  end

  \spec.gen:def!(
    pred
    () => protocol:transduce(protocol \put genit))

  \spec.explain:def!(
    pred
    () => (protocol:len == 0)
      :and "{}"
      :or ("{ " + explain_keys:(protocol, ', ') + " }"))

  pred
end

list.predicate = spec => do
  pred = .gab.string:('predicate:list:' spec):sigils.into

  \spec.fits?:def!(
    pred
    value => value:spec.fits_each? \values)

  \spec.gen:def!(
    pred
    () => .gab.list:():push(spec:spec.gen))

  \spec.explain:def!(
    pred
    () => .gab.string:('list[' spec:spec.explain() ']'))

  pred
end

record.predicate = (k_spec v_spec) => do
  pred = .gab.string('predicate:map:' k_spec ':' v_spec):sigils.into

  \spec.fits?:def!(
    pred
    value => do
      (value ? == .gab.record)
        :then(() => (.false self value))
        :else(() => do
          value :reduce(
            (v k) => do
              [ [k_spec, k], [v_spec, v] ] :spec.recursively
            end,
            )

          (.true, self, value)
        end)
    end)

  \spec.gen:def!(
    pred
    () => { k_spec:spec.gen,  v_spec:spec.gen })

  \spec.explain:def!(
    pred
    () => .gab.string:('Map[' k_spec:spec.explain ', ' v_spec:spec.explain ']'))

  pred
end

\spec.recursively :defcase! {
  # In the boolean cases, recurse if the spec matched
  # and bail early if it didn't
  .true (tail curr alt) => do
    tail:spec.recursively(alt**)
  end
  .false (tail curr alt) => do
    (self curr**)
  end
  # In the recursion cases, continue to check head 
  # until there is no tail
  .nil (alt[]) => do
    alt**
  end
  'gab.record' (alt[]) => do
    (spec value) = self:head**

    (does_fit result[]) = spec:spec.fits? value

    does_fit :spec.recursively (self:tail, result alt)
  end
}

spec.block.Args = { \input .nil \output .nil \semantics .nil }?

spec.block.Application = { \input .nil \output .nil \semantics .nil \in .nil \out .nil }?

\spec.block.input_fits?:def!(
  spec.block.Application
  () => self:input:spec.fits?(self:in**))

\spec.block.output_fits?:def!(
  spec.block.Application
  () => self:output:spec.fits?(self:out**))

\spec.semantics_fits?:def!(
  .nil
  (input output) => (.true .nil [input output]))

\spec.semantics_fits?:def!(
  'gab.block'
  (input output) => (self:(input output), self, [input output], .semantics))

block.predicate = (args semantics) => do
  args:assert.is? spec.block.Args

  pred = .gab.string:('predicate:block:' args ':' semantics):sigils.into

  \spec.fits?:def!(
    pred
    (input output) => do
      v = args
        :put(.input_value input)
        :put(.output_value output)

      v:first(
        \apply,
        [
          \spec.block.input_fits?,
          \spec.block.output_fits?,
          \spec.semantic_fits?,
        ],
        \options.into,
      )
    end)

  \spec.gen:def!(
    pred
    () => do
      block.gen = (input[]) => do
        .gab.range:(100):transduce(0, () => do
          # Generate an output
          (output[]) = args:output:spec.gen

          v = args
            :put(.input_value input)
            :put(.output_value output)

          v:first(
            \apply,
            [
              \spec.block.input_fits?,
              \spec.block.output_fits?,
              \spec.semantic_fits?,
            ],
            \options.into,
          )
        end):unwrap!
      end
    end)

  \spec.check:def!(
    pred
    (block) => do
      .gab.range:(100):transduce(() => do
        (input[]) = args:input:spec.gen

        args:input:spec.fits?(input**) :then do
          (output[]) = block:(input**)
          
          (.some, pred:(input, output))
        end
      end)
    end)
  
  pred
end

general_message.predicate = 'predicate:message' :sigils.into

\spec.fits?:def!(
  general_message.predicate
  (value) => (value:is_m?, self, value))

\spec.gen:def!(
  general_message.predicate
  \+)

\spec.explain:def!(
  general_message.predicate
  'message')

\spec.message.input_fits?:def!(
  'gab.record'
  () => self:input:spec.fits?(self:in**))

\spec.message.output_fits?:def!(
  'gab.record'
  () => self:output:spec.fits?(self:out**))

\spec.message.receiver_fits?:def!(
  'gab.record'
  () => self:receiver:spec.fits?(self:rec**))

\spec.message.semantics_fits?:def!(
  'gab.record'
  () => self
    :at \semantics
    :unwrap ()
    :spec.semantics_fits?(self:in, self:out))

\dospec.apply :defcase! {
  .true (v acc f) => [f : v]
  .false (v acc f) => acc
}

\-!> :def! (fs[]) => do
  me = self
  fs:reduce([.true]
    (so_far f) => so_far
      :at! 0
      :dospec.apply(me so_far f))**
end

\spec.message.define:defcase! {
  .nil general_message.predicate
  'gab.record' () => do
    args = self
    pred = .gab.string:('predicate:message:' args):sigils.into

    \spec.fits?:def!(
      pred
      (rec in out)
        => args
          :put(\rec rec)
          :put(\in in)
          :put(\out out)
           -!>(\spec.message.receiver_fits?
               \spec.message.input_fits?
               \spec.message.output_fits?
               \spec.message.semantics_fits?))

    \spec.gen:def!(
      pred
      receiver => do
        args:message:def!(
          receiver
          (input[]) => do
            (ok pred value path) = args:receiver:spec.fits? self

            (ok pred value path) = ok
              :or (ok pred value path)
              :then () => args:input:spec.fits?(input**)

            ok
              :or (ok pred value path)
              :then () => do
                (ok pred value path) = args:input:spec.fits?(input**)
                (output[]) = args:output:spec.gen
                iter = i:map(() => do
                    (output[]) = args:output:spec.gen

                    args:output:spec.fits?(output**) :then () => do
                      # If there are no semantics to satisfy, just return this output
                      (args:has? \semantics :else () => output**) :then () => do
                        rec = args:receiver:spec.gen

                        args:receiver:spec.fits?(rec) :then () => do

                          # Otherwise, we need to continue generating until we
                          # find a receiver and output which satisfy the semantics.
                          args:semantics:(input, output) :then () => do
                            # Return the generated output
                            (.ok output**)
                          end
                        end
                      end
                    end
                  end)            
                  |> i:filter \ok?
                  |> i:map \unwrap
                  |> i:take 1

                .gab.range:(100):transduce(.false \first iter)
          end
        end)

        args:message
      end)

    \spec.check:def!(
      pred
      () => do
        iter = i:map(() => do
            receiver = args:receiver:spec.gen

            args:receiver:spec.fits?(receiver) :then () => do
              (input[]) = args:input:spec.gen

              args:input:spec.fits?(input**) :then () => do
                (output[]) = args:message:(receiver input**)

                (ok res[]) = args:output:spec.fits?(output**)
                
                 ok:then () => do
                  args:has? \semantics
                    :or (ok, res**)
                    :then () => do
                      args:semantics:(input output)
                        :and(ok, res**)
                        :or(.false, args:semantics, [input output], 'semantics')
                    end
                end
              end
            end
          end)
          |> i:filter((valid? spec value path) => valid? !)
          |> i:map((valid? spec value path) => .gab.option:(valid? !, spec value path))
          |> i:take 1

        .gab.range:(100):transduce([.none] \all iter)**
      end)

    \spec.explain:def!(
      pred
      () =>.gab.string:(
        args:receiver:spec.name
        '\\'
        args:message
        ' '
        args:input:spec.name
        ' => '
        args:output:spec.name))

    pred
  end
}

message.predicate = args => args:spec.message.define

LabeledSpec = { \spec.label .nil \spec.spec .nil }?

\spec.label:def! spec.label => {
  \spec.label spec.label
  \spec.spec self
}

\spec.explain:def!(
  LabeledSpec
  () => .gab.string:(
    self:spec.label
    ': '
    self:spec.spec:spec.explain))

\spec.gen:def!(
  LabeledSpec
  () => self:spec.spec:spec.gen)

\spec.fits?:def!(
  LabeledSpec
  () => self:spec.spec:spec.fits?)

\spec.check:def!(
  LabeledSpec
  () => self:spec.spec:spec.check)

\spec.gen :def! () => self
\spec.explain :def! () => self
\spec.fits? :def! value => (self == value, self, value)

# Since a spec is just a predicate, we can simply call it and return the result
\spec.fits?:def!(
  'gab.block'
  (value) => self:(value))

\spec.option.into:defcase! {
  .nil err => do
    spec.t:any(.ok, err:or .err)    
  end
}

\spec.option.into:def! err => do
  value = self
  spec.t:any(
    spec.t:values(.ok, value),
    err:or .err,
  )
end

[spec.t] :defmodule! {
  \nil      nil.predicate,
  \unknown  unknown.predicate,
  \int      int.predicate,
  \float    float.predicate,
  \string   string.predicate,
  \shape    shape.predicate,
  \boolean  boolean.predicate,
  \block    block.predicate,
  \message  message.predicate,
  \list     list.predicate,
  \record   record.predicate,
  \values   values.predicate,
  \protocol protocol.predicate,
  \all      and.predicate,
  \any      or.predicate,
  \nilable  spec => spec.t:any(
                      spec
                      nil.predicate)
  \option  value => spec.t:any(
                      spec.t:values(.ok, value),
                      .none)
  \result  (value err) => value:spec.option.into err
  \gt (min) => do
    gt.predicate = .gab.string:('predicate:gt:' min):sigils.into

    \spec.fits?:def!(
      gt.predicate
      (value) => (value > min, self, value))

    \spec.explain:def!(gt.predicate, '> {min}')

    gt.predicate
  end
  \lt max => do
    lt.predicate = .gab.string:('predicate:lt:' max):sigils.into

    \spec.fits?:def!(
      lt.predicate
      (value) => (value < max, self, value))

    \spec.explain:def!([lt.predicate] '< {max}')

    lt.predicate
  end
}

spec.t
