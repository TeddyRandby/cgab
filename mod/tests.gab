i = 'iter':use

implementations = .gab.message :impls

xf = (i:filter m => do
        m:strings.into:ends? '.test'
     end) |> (i:map (m, impls) => do
        (path[], _) = m:strings.into:split '.'

        'm':print m
        'PATH':print path

        path = path:transduce({}, \push, i:map \first)


        (path, { \path path, \impls impls })
     end)

# Collect all the implementations into a giant, nested map.
tests.all = implementations:transduce({}, (t, p, i) => do
  'PUTVIA: $ $ $\n':printf(t i p)
  t:put_via(i, p**)
end, xf)

suites.all = tests.all :reduce({}, (suites, suite) => do
  suites :put (suite, .gab.channel:())
end)

\test.compare :def! ('gab.block', 'gab.message', (lhs, rhs) => do
  self:(lhs, rhs)
end)

test.result.t = { \test.path .nil, \test.receiver .nil }?
test.result.pass.t = { \test.path .nil, \test.receiver .nil, \test.meta .nil,  .true .nil }?
test.result.fail.t = { \test.path .nil, \test.receiver .nil, \test.meta .nil, .false .nil }?

[test.result.t] :defmodule! {
  \expect (lhs, cmp, rhs) => do
    # Run the comparison of the expect
    test.outcome = cmp :test.compare (lhs, rhs)
    # Get the suite we're executing
    suite = self:test.path :at! 0
    # Queue up the outcome of the comparison
    suites.all :at! suite <! self :put (\test.meta, { \lhs lhs, \cmp cmp, \rhs rhs }) :put test.outcome
  end,
}

\test.result.display :defcase! {
  \test.result.pass.t _ => do
    #" ✔ $ $ $\n" :printf (self:test.meta**)
    .nil
  end
  \test.result.fail.t _ => do
    (suite, behavior) = self:test.path**
    " ❌$ should $\n\t$ $ $\n" :printf (suite, behavior, self:test.meta**)
  end,
}

.gab.fiber _ => do
  suites.all :each (s c) => do
    "✔ $\n" :printf (s)
    c :each \test.result.display
  end
end

tests.all :each (suite, behaviors) => do 
  .gab.fiber _ => do
    behaviors :each (_, runnable) => do 
      (path, body) = runnable**

      body :each (r t) => do
        t { \test.path: path, \test.receiver: r }
      end
    end

    suites.all :at! suite :close!
  end
end
