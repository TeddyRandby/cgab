iter       = 'iter':use

truthy_values = []
falsey_values = [.nil .false .none .err]

\self :def! do _ => self end
\first :def! do x => x end
\second :def! do (_, x) => x end
\all :def! do (xs[]) => xs end

\is? :def! do other => self:?:== other end

truthy_values :defmodule! {
  \and (alt[]) => alt**
  \then f => f: self
  \or _ => self
  \else _ => self
  \assert! _ => self
}

falsey_values :defmodule! {
  \and _ => self
  \then _ => self
  \or (alt[]) => alt**
  \else f => f: self
  \assert! msg => ('Assert failed: ' + msg):panic
  \options.into .none,
  \results.into .err,
}

[] :defmodule! {
  \options.into (args[]) => (.ok, self, args**)
  \results.into (args[]) => (.ok, self, args**)
}

\:def!(
  .gab.option
  (cond, data[]) => do
    (cond:options.into, data**)
  end)

\:def!(
  .gab.result
  (cond, data[]) => (cond:results.into, data**))

[.ok] :defmodule! {
  \ok? (args[]) => (.true, args**)
  \unwrap (args[]) => args**
  \unwrap! (args[]) => args**
}

[] :defmodule! {
  \ok? .false,
  \unwrap .nil,
  \unwrap! msg => ('failed to unwrap' + self + ": " + msg):panic
}

## Can we refactor this and iter mod into tail calls?
\doreduce :defcase! {
  ## The sequence continues
  .ok (seq.i seq.v acc r xs) => do
    # Apply the reducer
    (cmd r acc) = r:reduce.step(acc xs**)
    # proceed to the next sep
    cmd:doreduce(seq.i seq.v acc r)
  end
  ## The sequence is done
  .none (seq.i seq.v acc r) => do
    r:reduce.done(acc)
  end
  ## The reducer continues
  .next (seq.i seq.v acc r) => do
    # Apply the producer resolving new values for the next step
    (ok seq.v xs[]) = seq.i :seqs.next seq.v
    # Tailcall to the next step
    ok:doreduce(seq.i seq.v acc r xs)
  end
  ## The reducer is done
  .stop (seq.i seq.v acc r) => do
    r:reduce.done(acc)
  end
}

\def.seq! :def! do
  _ => [self] :defmodule! {
    \reduce (acc, r) => do
      (ok, seq.v, xs[]) = self :seqs.init
      ok:doreduce(self, seq.v, acc, r, xs)
    end,
    \transduce (acc, r, td) => do
      self:reduce(acc, td :iter.apply r)
    end,
    \each f => do
      self:transduce(.nil, \all, iter:tap f)
    end,
    \map f => do
      self:collect(iter:map f)
    end,
    \filter f => do
      self:collect(iter:filter f)
    end,
    \join xf => do
      self:transduce("", \+, xf)
    end,
    \collect xf => do
      self:transduce({}, \push, xf)
    end,
  }
end

channels.t = 'gab.channel'

# Channel's implementation of the seq protocol.
# It isn't totally true to the requirements - 
# The keys aren't a pure function, because channels
# Forget about their values as soon as their taken
[channels.t] :defmodule! {
  \seqs.init _ => do
    (ok v) = self >!
    (ok v v)
  end
  \seqs.next _ => do
    (ok v) = self >!
    (ok v v)
  end
}

channels.t :def.seq!

# Implement the reducer protocol for blocks and messages
['gab.block' 'gab.message'] :defmodule! {
  \reduce.step (acc, xs[]) => do
    (.next self self:(acc xs**))
  end
  \reduce.done acc => acc
}

records.t = 'gab.record'

[records.t] :defmodule! {
  \has? key => do
    self:at key :ok?
  end
  \at! key => do
    self:at key :unwrap!
  end,
}

records.t :def.seq!

\ :def! (.int.between, (min, max) => do
  .float.between:(min,max) :floor
end)


range.t = { \from .nil, \to .nil }?

range.t :def.seq!

[range.t] :defmodule! {
  \seqs.init _ => do
    (.ok, self:from, self:from)
  end
  \seqs.next n => do
    nx = n + 1
    .gab.option:(n < self:to, nx, nx)
  end
}

\range.into :defcase! {
  .nil to => do
    { \from 0, \to to }
  end
  'gab.number' from => do
    { \from from, \to self }
  end
}

\ :def! (.gab.range (from to) => do
  (to from) :range.into
end)

numbers.t = 'gab.number'

\is_n? :def! .false
\is_n? :def! (numbers.t, .true)

\numbers.into :def! (falsey_values, 0)

[numbers.t] :defmodule! {
  \-> to => (to self) :range.into
  \++ _ => self + 1
  \-- _ => self - 1
  \even? _ => self :% 2 :== 0
  \odd? _ => self :even? :!
  \pos? _ => self > 0
  \neg? _ => self < 0
  \numbers.into _ => self
}
