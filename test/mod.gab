'std':require

def describe = do (name, cb)
  ('\n--{name}--'):print
  cb()
end

def it = do(name, cb)
  print('{cb() and '✓' or '×'} it {name}')
end

def check = do(result, msg)
  result or print(msg)
end

def expect = do (a, b)
  check(a == b, 'Expected {a} to be equal to {b}') or panic()
end

def expect_not = do (a, b)
  check(not (a == b), 'Expected {a} to not be equal to {b}') or panic()
end

describe('Numbers', do ()
  it('should be equal to itself', do ()
    expect(5, 5)
  end)

  it('should do math', do ()
    expect(5 * 2, 10)
    expect(10 % 3, 1)
  end)
end)

describe('Strings', do ()
  it('should be equal to itself', do ()
    expect('hello', 'hello')
  end)

  it('should concatenate', do ()
    expect(('hello' + ' world'), 'hello world')
  end)

  it('should interpolate', do ()
    expect(('{1} + {2} is {1 + 2}'),'1 + 2 is 3')
  end)
end)


describe('Closures', do ()
    def a = 1

    it('should capture', do ()
        expect(a, 1)

        def test = do()
           expect(a, 1)
           a  
        end

        expect(test(), 1)
        expect(test(), 1)
        expect(test(), 1)
    end)

   it('should work with varargs', do()

      def varfunc = do(first, ..args)
        expect(first, 1)
        expect(args[0], 2)
      end

      varfunc(1,2)

      def onetwo = do()
        return 1, 2
      end

      varfunc(onetwo())
   end)
end)

describe('Records', do ()
  def Point { x y }

  it('should have properties', do ()
    let point = {
      x = 1
      y = 2
    }

    expect(point.x, 1)
    expect(point.y, 2)
  end)

  it('should be structurally shaped', do ()
    let pone = { x = 1 y = 2}
    let ptwo = { x = 3 y = 4}

    expect(?pone, ?ptwo)
  end)

  it('should work for all kinds of keys', do ()
    let obj = {
        [?{}] = 3
        [it]  = it
    }

    expect(obj[?{}],3)
    expect(obj[it],it)
  end)

  it('should work when shapes change', do ()
    let justa = { a }
    let ab = { a = 3 b }
    let abc = { a = 'hi' b c}

    def get_a[?{ a }]
        self.a
    end

    def get_a[?{ a b }]
        self.a
    end
    
    def get_a[?{ a b c }]
        self.a
    end
    
    expect(justa:get_a,true)

    expect(ab:get_a,3)

    expect(abc:get_a,'hi')

    expect(ab:get_a,3)
    expect(ab:get_a,3)

    ab.a = 5

    expect(abc:get_a, 'hi')

    expect(ab:get_a, 5)
    expect(justa:get_a, true)
  end)

  it('should make tuples', do ()
    let tup = [ 1 2 3 ]

    expect(tup[0],1)
    expect(tup[1],2)
    expect(tup[2],3)
  end)
end)

describe('Overloads', do ()
    def Vector { x y }

    def + [Vector](other)
        other is Vector or panic()

        {
            x = self.x + other.x
            y = self.y + other.y
        }
    end

    it('should overload binary', do ()
        let test = { x=1 y=2 } + { x=2 y=1 }

        expect(test.x,3)
        expect(test.y,3)
    end)

    def < [Vector](other)
        other is Vector or panic()

        let mag = self.x * self.x + self.y * self.y
        let other_mag = other.x * other.x + other.y * other.y

        mag < other_mag
    end

    def == [Vector](other)
        (self.x == other.x) and (self.y == other.y)
    end

    it('should overload comparison', do ()
        let test = { x=1 y=1 } < { x=4 y=4 }
        expect(test,true)

        test = { x=1 y=1 } == { x=1 y=1 }

        expect(test,true)
    end)

    def get = do (obj, key) obj[key] end

    it('should get before overload', do()
        expect(get({ x = 1 y = 2}, 'x'),1)
    end)


    def [] [Vector](key)
       key == 'mag' then
        return self.x * self.x + self.y * self.y
       end
    end

    it('should overload get', do ()
        expect(get({ x = 2 y = 2 },'mag'),8)
    end)

    it('should behave when switching types', do ()
      def sum = do (a,b)
        a + b
      end

      #expect(sum(1,2),3)
      #expect(sum('h','i'),'hi')
      expect(sum({x = 1 y = 2}) {x = 2 y = 1}) {x = 3 y = 3} # Should work because of eq overload
      expect(sum(1,2),3)
      expect(sum('h','i'),'hi')
    end)
end)

describe('Messages', do ()
    def test[]
        self    
    end

    it('should send', do ()
        expect(1:test, 1)
    end)

    def test[Number](a)
        self + 1
    end

    it('should use more specific', do ()
        expect(1:test, 2)
    end)

    def repeat = do 1:test end

    it('should cache', do
        expect(repeat(),2)
        expect(repeat(),2)
        expect(repeat(),2)
    end)

    def oneTwo = do return 1, 2 end

    it('should send/receive var', do ()
      def takeOneTwo = do (a, b)
        expect(a,1)
        expect(b,2)
      end

      takeOneTwo(oneTwo())
    end)
end)

describe('Effects', do ()
    def once = do
        yield 1
        2
    end

    def twice = do
        yield 1
        yield 2

        3
    end

    def receive_one = do
        let val = yield

        expect(val,1)
    end

    def receive_onetwo = do
        let one, two = yield
        
        expect(one,1)
        expect(two,2)
    end

    def onetwo = do
        return 1,2 
    end

    def yields_many = do
        yield onetwo()
    end

   it('should yield once', do ()
       let val, eff = once()

       expect(val,1)
       expect(eff(),2)
   end)

    it('should yield twice', do()
        let _, eff = twice()

        let valtwo, efftwo = eff()

        expect(valtwo,2)
        expect(efftwo(),3)
    end)

   it('should receive a value', do ()
       let eff = receive_one()

       eff(1)
   end)

   it('should yield var', do ()
       let one, two, eff = yields_many()
       expect(one,1)
       expect(two,2)
   end)

   it('should receive var', do ()
       let eff = receive_onetwo()

       eff(onetwo())
   end)
end)

describe('Lists', do ()
    it('should create', do ()
        let list = List:new(100)

        expect_not(list,nil)
    end)

    it('should put', do ()
        let list = List:new

        expect(list:at(0), nil)

        list:push('hello')

        expect(list:at(0), 'hello')

        list:put(2, 'hello')

        expect(list:at(2), 'hello')
    end)

    it('should get/set', do ()
        let list = List:new

        expect(list[0],nil)

        list[0] = 5

        expect(list[0],5)

        list[10] = 10

        expect(list[10],10)

        expect(list[9],nil)
    end)

    it('should index with range', do ()
        let list = List:new(5)
        list[0] = 1
        list[1] = 2
        list[2] = 3
        list[3] = 4
        list[4] = 5

        let slice = list[3:to]

        expect(slice[0],1)
        expect(slice[2],3)

        slice = list[3:to(4)]

        expect(slice[0],4)
        expect(slice[1],nil)
    end)
end)

describe('Maps', do ()
  it('should create', do ()
    let map = Map:new

    expect_not(map,nil)
  end)

  it('should create with initial', do ()
    let map = Map:new { hi = 'bob' }

    expect_not(map,nil)

    expect(map:at('hi'), 'bob')
  end)

  it('should put', do ()
    let map = Map:new

    map:put('hi', 'bob')

    expect(map:at('hi'), 'bob')
    expect(map:at('bye'), nil)
  end)

  it('should get/set', do ()
    let map = Map:new

    map['hi'] = 'bob'

    expect(map['hi'],'bob')
    expect(map['bye'],nil)
  end)
end)
