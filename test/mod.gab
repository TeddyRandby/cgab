:use .tests
:use .numbers
:use .any

:describe 'Multiple Assignment' do
    :it 'should declare new variables' do
        (a = 2):expect(2)
        a:expect(2)

        (a = 3):expect(3)
        a:expect(3)
    end

    :it 'should assign multiple variables' do
        (a, b = 1, 2):expect(1)
        a:expect(1)
        b:expect(2)
        (a, b = b, a):expect(2)
        a:expect(2)
        b:expect(1)
    end

    :it 'should reassign' do
      (a, b, c, d = 1, 2, 3, 4):expect(1)
      a:expect(1)
      b:expect(2)
      c:expect(3)
      d:expect(4)

      (a, c, d, e = 5, 6, 7, 8):expect(5)
      a:expect(5)
      c:expect(6)
      d:expect(7)
      e:expect(8)
    end

    :it 'should rest assign a constant multi value' do
        (a, b,..c = 1, 2, 3, 4, 5):expect(1)
        a:expect(1)
        b:expect(2)
        c[0]:expect(3)
        c[1]:expect(4)
        c[2]:expect(5)
    end

    :it 'should rest assign a constant multi value in middle' do
        (a, ..b, c = 1,2,3,4,5):expect(1)

        a:expect(1)
        c:expect(5)
        b[0]:expect(2)
        b[1]:expect(3)
        b[2]:expect(4)
    end

    :it 'should rest assign a runtime multi value' do
        one_through_five = do; return 1,2,3,4,5 end

        (..a, b, c = one_through_five())

        b:expect(4)
        c:expect(5)
        a[0]:expect(1)
        a[1]:expect(2)
        a[2]:expect(3)
    end

    :it 'should rest assign to existing variables' do
        one_through_five = do; return 1,2,3,4,5 end

        b = 1

        (a, ..b, c = one_through_five()):expect(1)

        a:expect(1)
        c:expect(5)
        b[0]:expect(2)
        b[1]:expect(3)
        b[2]:expect(4)
    end

    :it 'should mix locals and properties' do
        a = { b, c }

        (a:b, d, a:c = 1, 2, 3):expect(1)
        a:b:expect(1)
        d:expect(2)
        a:c:expect(3)

        (e, a:b, a:c = 1, 2, 3):expect(1)
        e:expect(1)
        a:b:expect(2)
        a:c:expect(3)

        (a:c, a:b, e = 1, 2, 3):expect(1)
        a:c:expect(1)
        a:b:expect(2)
        e:expect(3)
    end

    :it 'should mix locals and sets' do
        a = { b, c }

        (a['b'], d, a['c'] = 1, 2, 3):expect(1)
        a:b:expect(1)
        d:expect(2)
        a:c:expect(3)

        (e, a['b'], a['c'] = 1, 2, 3):expect(1)
        e:expect(1)
        a:b:expect(2)
        a:c:expect(3)

        (a['c'], a['b'], e = 1, 2, 3):expect(1)
        a:c:expect(1)
        a:b:expect(2)
        e:expect(3)
    end
end

:describe 'Numbers'  do
  :it 'should be equal to itself' do
    5:expect(5)
  end

  :it 'should do math' do
    10:expect(5 * 2)
    1:expect(10 % 3)
    8:expect(1 << 3)
  end

  :it 'should compare' do
    (5 < 10):expect(true)
    (10 > 5):expect(true)
  end

  :it 'should dynamically do numberics' do
    (1:(&+)(2)):expect(3)
    (1:(&-)(2)):expect(-1)
  end
end

:describe 'Strings' do
  :it 'should be equal to itself' do
    'hello':expect('hello')
  end

  :it 'should concatenate'  do
    'hello world':expect('hello' + ' world')
  end

  :it 'should interpolate'  do
    '1 + 2 is 3':expect('{1} + {2} is {1 + 2}')
  end
end


:describe 'Blocks'  do
    def a = 1

    :it 'should capture'  do
        a:expect(1)

        def test = do
           a:expect(1)
           a  
        end

        test():expect(1)
    end

   :it 'should work with varargs'  do
      def varfunc = do (first, ..args)
        first:expect(1)
        args[0]:expect(2)
      end

      varfunc(1,2)

      def onetwo = do; return 1, 2 end

      varfunc(onetwo())
   end

   :it 'should work more with varargs'  do
      def varfunc = do (first, ..args, last)
        first:expect(1)
        args[0]:expect(2)
        last:expect(3)
      end

      varfunc(1,2,3)

      def onetwothree = do; return 1, 2, 3 end

      varfunc(onetwothree())
   end

   :it 'should make var args empty when necessary' do
      def varfunc = do (first, ..args, other, last)
        first:expect(1)
        args:len:expect(0)
        other:expect(2)
        last:expect(nil)
      end

      varfunc(1,2)

      def onetwo = do; return 1, 2 end

      varfunc(onetwo())

   end

   :it 'should take implicit parameters'  do
        def imp_func = do (a)
            a:expect(@1)
        end

        imp_func(1)
   end

   :it 'should add implicit parameters'  do
        def imp_func = do
            @1:expect(1)
            @2:expect(2)
        end

        imp_func(1,2)
   end
end

:describe 'Records' do
  def Point { x, y }

  :it('should have properties') do
    point = {
      x = 1,
      y = 2
    }

    point:x:expect(1)
    point:y:expect(2)
  end

  :it('should be structurally shaped') do
    pone = { x = 1, y = 2}
    ptwo = { x = 3, y = 4}

    (?pone):expect(?ptwo)
  end

  :it('should work for all kinds of keys') do
    obj = {
        [?{}] = 3,
        [.hi] = 4
    }

    3:expect(obj[?{}])
    4:expect(obj[.hi])
  end

  :it('should work when shapes change') do
    justa = { a }
    ab = { a = 3, b }
    abc = { a = 'hi', b, c}

    def get_a[?{ a }]
        self:a
    end

    def get_a[?{ a, b }]
        self:a
    end
    
    def get_a[?{ a, b, c }]
        self:a
    end

    def test_get_a = do (obj, v)
        obj:get_a:expect(v)
    end


    test_get_a(justa, true)

    test_get_a(ab, 3)

    test_get_a(abc, 'hi')

    test_get_a(ab, 3)
    test_get_a(ab, 3)

    ab:a = 5

    test_get_a(abc, 'hi')

    test_get_a(ab, 5)

    test_get_a(justa, true)
  end

  :it('should make tuples') do
    tup = [ 1, 2, 3 ]

    tup[0]:expect(1)
    tup[1]:expect(2)
    tup[2]:expect(3)
  end

  :it 'should make var tuples' do
    def onetwothree; return 1, 2, 3 end

    tup = [ onetwothree() ]

    tup[0]:expect(1)
    tup[1]:expect(2)
    tup[2]:expect(3)

    tup = [ true and onetwothree() ]
    tup[0]:expect(1)
    tup:len:expect(1)

    tup = [ true or onetwothree() ]
    tup[0]:expect(true)
    tup:len:expect(1)

    tup = true and [ onetwothree() ]
    tup[0]:expect(1)
    tup[1]:expect(2)
    tup[2]:expect(3)
  end
end

:describe('Overloads') do
    def Vector { x, y }

    def + [Vector](other)
        other:is?(Vector) or .INVALID_ARGUMENTS:panic

        {
            x = self:x + other:x,
            y = self:y + other:y
        }
    end

    :it('should overload binary') do
        test = { x = 1, y = 2 } + { x = 2, y = 1 }

        3:expect(test:x)
        3:expect(test:y)
    end

    def < [Vector](other)
        other:is?(Vector) or .INVALID_ARGUMENTS:panic

        mag = self:x * self:x + self:y * self:y
        other_mag = other:x * other:x + other:y * other:y

        mag < other_mag
    end

    def == [Vector](other)
        (self:x == other:x) and (self:y == other:y)
    end

    :it('should overload comparison') do
        { x = 1, y =  1 }:expect({ x = 1, y = 1})
        ({ x = 1, y = 2 } < { x = 4, y = 4}):expect(true)
    end

    def get = do (obj, key)
        obj[key]
    end

    :it('should get before overload') do
        1:expect(get({ x = 1, y = 2}, 'x'))
    end


    def [] [Vector](key)
       key == 'mag' then
        return self:x * self:x + self:y * self:y
       end
    end

    :it('should overload get') do
        8:expect(get({ x = 2, y = 2 },'mag'))
    end

    :it('should behave when switching types') do
      def sum = do (a,b)
        a + b
      end

      3:expect(sum(1,2))
      {x = 3, y = 3}:expect(sum({x = 1, y = 2}, {x = 2, y = 1}))
      'hi':expect(sum('h','i'))
      'hi':expect(sum('h','i'))
      {x = 3, y = 3}:expect(sum({x = 1, y = 2}, {x = 2, y = 1}))
      3:expect(sum(1,2))
    end
end

:describe('Messages') do
    def test[]
        self    
    end

    :it('should send') do
        1:expect(1:test)
    end

    def test[.Number](a)
        self + 1
    end

    :it('should use more specific') do
        2:expect(1:test)
    end

    def repeat = do; 1:test end

    :it('should cache') do
        2:expect(repeat())
        2:expect(repeat())
        2:expect(repeat())
    end

    def oneTwo = do; return 1, 2 end

    :it('should send/receive var') do
      def takeOneTwo = do (a, b)
        1:expect(a)
        2:expect(b)
      end

      takeOneTwo(oneTwo())
    end
end

:describe('Suspensions') do
    def once = do
        yield 1
        2
    end

    def twice = do
        yield 1
        yield 2

        3
    end

    def receive_one = do
        val = yield

        val:expect(1)
    end

    def receive_onetwo = do
        one, two = yield
        
        one:expect(1)
        two:expect(2)
    end

    def onetwo = do
        return 1,2 
    end

    def yields_many = do
        yield onetwo()
    end

   :it('should yield once') do
       val, eff = once()

       val:expect(1)
       eff():expect(2)
   end

   :it('should yield twice') do
       _, eff = twice()

       valtwo, efftwo = eff()

       valthree = efftwo()

       valtwo:expect(2)
       efftwo():expect(3)
   end

   :it('should receive a value') do
       eff = receive_one()

       eff(1)
   end

   :it('should yield var') do
       one, two, eff = yields_many()
       1:expect(one)
       2:expect(two)
   end

   :it('should receive var') do
       eff = receive_onetwo()

       eff(onetwo())
   end
end
