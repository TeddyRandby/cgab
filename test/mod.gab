t = 'tests' :use

t :tests.covers 'Multiple Assignment'     .
    :tests.should 'declare new variables' .
    :tests.when do t:
        a = 2

        t:tests.expect(a, \==, 2)

        a = 3

        t:tests.expect(a, \==, 3)
    end                                       .
    :tests.should 'assign multiple variables' .
    :tests.when do t:
        a, b = 1, 2

        t:tests.expect(a, \==, 1)
        t:tests.expect(b, \==, 2)

        a, b = b, a
        t:tests.expect(a, \==, 2)
        t:tests.expect(b, \==, 1)
    end                                .
    :tests.should 'reassign variables' .
    :tests.when do t:
        a, b, c, d = 1, 2, 3, 4

        t:tests.expect(a, \==, 1)
        t:tests.expect(b, \==, 2)
        t:tests.expect(c, \==, 3)
        t:tests.expect(d, \==, 4)

        a, c, d, e = 5, 6, 7, 8

        t:tests.expect(a, \==, 5)
        t:tests.expect(c, \==, 6)
        t:tests.expect(d, \==, 7)
        t:tests.expect(e, \==, 8)
    end .
    :tests.should 'rest assign a constant multi value' .
    :tests.when do t:
        a, b, c[] = 1, 2, 3, 4, 5

        t:tests.expect(a, \==, 1)
        t:tests.expect(b, \==, 2)
        t:tests.expect(c:at! 0, \==, 3)
        t:tests.expect(c:at! 1, \==, 4)
        t:tests.expect(c:at! 2, \==, 5)
    end .
    :tests.should 'rest assign a constant multi value in middle' .
    :tests.when do t:
        a, b[], c = 1, 2, 3, 4, 5

        t:tests.expect(a, \==, 1)
        t:tests.expect(c, \==, 5)
        t:tests.expect(b:at! 0, \==, 2)
        t:tests.expect(b:at! 1, \==, 3)
        t:tests.expect(b:at! 2, \==, 4)
    end .
    :tests.should 'rest assign a runtime multi value' .
    :tests.when do t:
        one_through_five = do: (1,2,3,4,5) end

        a[], b, c = one_through_five ()

        t:tests.expect(b, \==, 4)
        t:tests.expect(c, \==, 5)
        t:tests.expect(a:at! 0, \==, 1)
        t:tests.expect(a:at! 1, \==, 2)
        t:tests.expect(a:at! 2, \==, 3)
    end .
    :tests.should 'rest assign to existing variables' .
    :tests.when do t:
        one_through_five = do: (1,2,3,4,5) end

        b = 1

        a, b[], c = one_through_five ()

        t:tests.expect(a, \==, 1)
        t:tests.expect(c, \==, 5)
        t:tests.expect(b:at! 0,\==, 2)
        t:tests.expect(b:at! 1,\==, 3)
        t:tests.expect(b:at! 2,\==, 4)
    end

t :tests.covers 'Numbers' .
    :tests.should 'equal itself' .
    :tests.when do t:
        t:tests.expect(5, \==, 5)
    end .
    :tests.should 'do math' .
    :tests.when do t:
        t:tests.expect(10, \==, 5 * 2)
        t:tests.expect(1, \==, 10 % 3)
        t:tests.expect(8, \==, 1 << 3)
    end .
    :tests.should 'compare' .
    :tests.when do t:
        t:tests.expect(5 < 10, \==, .true)
        t:tests.expect(10 > 5, \==, .true)
    end .
    :tests.should 'dynamically do arithmetic' .
    :tests.when do t:
        t:tests.expect(\+(1, 2), \==, 3)
        t:tests.expect(\+(1,2, .ignore_me), \==, 3)
        t:tests.expect(\-(1,2), \==, -1)
    end

t :tests.covers 'Strings' .
    :tests.should 'equal itself' .
    :tests.when do t:
        t:tests.expect('hello', \==, 'hello')
    end .
    :tests.should 'concatenate' .
    :tests.when do t:
        t:tests.expect('hello world', \==, 'hello' + ' world')
    end .
    :tests.should 'interpolate' .
    :tests.when do t:
        t:tests.expect('{'hi'} {'world'}', \==, 'hi world')
    end .
    :tests.should 'dynamically concatenate' .
    :tests.when do t:
        t:tests.expect(\+('hi ', 'world'), \==, 'hi world')
        t:tests.expect(\+('hi ', 'world', .ignore_me), \==, 'hi world')
    end .
    :tests.should 'append sigils' .
    :tests.when do t:
        t:tests.expect(\+('hi ', .world), \==, 'hi world')
        t:tests.expect(('hi ' + .world), \==, 'hi world')
    end

capture_me = 1

t :tests.covers 'Blocks' .
    :tests.should 'capture' .
    :tests.when do t:
        t:tests.expect(capture_me, \==, 1)

        test = do:
           t:tests.expect(capture_me, \==, 1)
           capture_me  
        end

        t:tests.expect(test(), \==, 1)
    end .
    :tests.should 'work with varargs' .
    :tests.when do t:
        varfunc = do first, args[]:
          t:tests.expect(first, \==, 1)
          t:tests.expect(args:at! 0, \==, 2)
        end

        varfunc(1,2)

        onetwo = do: (1, 2) end

        varfunc(onetwo())

        varfunc = do first, args[], last:
          t:tests.expect(first, \==, 1)
          t:tests.expect(args:at! 0, \==, 2)
          t:tests.expect(last, \==, 3)
        end

        varfunc(1,2,3)

        onetwothree = do: (1, 2, 3) end

        varfunc(onetwothree())
    end .
    :tests.should 'make var args empty when necessary' .
    :tests.when do t:
        varfunc = do first, args[], other, last:
          t:tests.expect(first, \==, 1)
          t:tests.expect(args:len, \==, 0)
          t:tests.expect(other, \==, 2)
          t:tests.expect(last, \==, .nil)
        end

        varfunc(1,2)

        onetwo = do: (1, 2) end

        varfunc(onetwo())
    end

Point = { x, y }?

t :tests.covers 'Records' .
    :tests.should 'have properties' .
    :tests.when do t:
        point = {
          x = 1,
          y = 2
        }

        t:tests.expect(point:x, \==, 1)
        t:tests.expect(point:y, \==, 2)
    end .
    :tests.should 'be structurally shaped' .
    :tests.when do t:
        pone = { x = 1, y = 2}
        ptwo = { x = 3, y = 4}

        t:tests.expect(pone:?, \==, ptwo:?)
    end .
    :tests.should 'work for all kinds of keys' .
    :tests.when do t:
        obj = {
            [{}?] = 3,
            [.hi] = 4
        }

        t:tests.expect(3, \==, obj:at!({}?))
        t:tests.expect(4, \==, obj:at!(.hi))
    end .
    :tests.should 'make tuples' .
    :tests.when do t:
        tup = [ 1, 2, 3 ]

        t:tests.expect(tup:at! 0, \==, 1)
        t:tests.expect(tup:at! 1, \==, 2)
        t:tests.expect(tup:at! 2, \==, 3)
    end .
    :tests.should 'make var tuples' .
    :tests.when do t:
        onetwothree = do:
          (1, 2, 3)
        end

        tup = [ onetwothree() ]
        t:tests.expect(tup:at! 0, \==, 1)
        t:tests.expect(tup:at! 1, \==, 2)
        t:tests.expect(tup:at! 2, \==, 3)
        t:tests.expect(tup:len, \==, 3)
    end

vec.t = { x, y }?


t :tests.covers 'Overloads' .
    :tests.should 'overload binary' .
    :tests.when do t:
        \+ :def! (vec.t, do other:
          {
            x = self:x + other:x,
            y = self:y + other:y,
          }
        end)

        a = { x = 1, y = 2 }
        b = { x = 2, y = 1 }
        test = a + b

        t:tests.expect(test:x, \==, 3)
        t:tests.expect(test:y, \==, 3)
    end .
    :tests.should 'overload comparison' .
    :tests.when do t:
        \< :def!(vec.t, do other:
          mag = ((self:x) * (self:x)) + ((self:y) * (self:y))
          other_mag = ((other:x) * (other:x)) + ((other:y) * (other:y))
          mag < other_mag
        end)

        \== :def!(vec.t, do other:
          (self:x == other:x) & (self:y == other:y)
        end)

        a = { x = 1, y = 1 }
        b = { x = 1, y = 1 }
        t:tests.expect(a, \==, b)
        b = { x = 4, y = 4 }
        t:tests.expect(a, \<, b)
    end .
    :tests.should 'handle changing overloads' .
    :tests.when do t:
        get = do obj, key:
            obj:at!(key)
        end

        t:tests.expect(get({ x = 1, y = 2 }, \x), \==, 1)

        \at! :def! (vec.t, do key:
          v = self
          (key == 'mag') :then do:
            ((v:x) * (v:x)) + ((v:y) * (v:y))
          end
        end)

        t:tests.expect(get({ x = 2, y = 2 }, 'mag'), \==, 8)
    end .
    :tests.should 'handle switching types' .
    :tests.when do t:
      sum = do a, b:
        a + b
      end

      a = { x = 3, y = 3 }
      b = { x = 1, y = 2 }
      c = { x = 2, y = 1 }

      t:tests.expect(3, \==, sum(1,2))
      t:tests.expect(a, \==, sum(b, c))
      t:tests.expect('hi', \==, sum('h','i'))
      t:tests.expect('hi', \==, sum('h','i'))
      t:tests.expect(a, \==, sum(b, c))
      t:tests.expect(3, \==, sum(1,2))
    end

\test :def! do: self end

\test :def! ('gab.number', do:
    self + 1
end)

t :tests.covers 'Messages' .
    :tests.should 'send' .
    :tests.when do t:
        t:tests.expect(1, \==, 1:test)
    end .
    :tests.should 'use more specific spec' .
    :tests.when do t:
        t:tests.expect(1:test, \==, 2)
    end .
    :tests.should 'cache' .
    :tests.when do t:
        repeat = do: 1:test end

        t:tests.expect(repeat(), \==, 2)
        t:tests.expect(repeat(), \==, 2)
        t:tests.expect(repeat(), \==, 2)
    end .
    :tests.should 'send/receive var tuples' .
    :tests.when do t:
        oneTwo = do: (1, 2) end

        takeOneTwo = do a, b:
          t:tests.expect(1, \==, a)
          t:tests.expect(2, \==, b)
        end

        takeOneTwo(oneTwo())
    end .
    :tests.should 'send constants' .
    :tests.when do t:
        \hi :def! ('gab.number', .test)

        t:tests.expect(1:hi, \==, .test)
    end .
    :tests.should 'send messages dynamically' .
    :tests.when do t:
        sum = do a, b:
          \+(a, b)
        end

        result = sum(1,1)

        t:tests.expect(result, \==, 2)

        result = sum(2, 2)

        t:tests.expect(result, \==, 4)

        result = sum('hi', ' world')

        t:tests.expect(result, \==, 'hi world')

        result = \hi { hi = 8 }

        t:tests.expect(result, \==, 8)

        result = \put({ hi = 8 }, \hi , 2)

        t:tests.expect(result:hi, \==, 2)

        result = \** ['hi']

        t:tests.expect(result, \==, 'hi')

        result = \hi({ hi }, 4)

        t:tests.expect(result:hi, \==, 4)
    end
