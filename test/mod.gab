def describe(name, cb)
  ('\n--{name}--'):print
  cb()
end

def it(name, cb)
  ('{cb() and '✓' or '×'} it {name}'):print
end

def check(result, msg)
  result or print(msg)
end

def expect[](other)
  check(self == other, 'Expected {self} to be equal to {other}')
end

describe('Numbers', do ()
  it('should be equal to itself', do ()
    5:expect(5)
  end)
  it('should do math', do ()
    (5 * 2):expect(10) and
    (10 % 3):expect(1)
  end)
end)

describe('Strings', do ()
  it('should be equal to itself', do ()
    'hello':expect('hello')
  end)

  it('should concatenate', do ()
    ('hello'..' world'):expect('hello world')
  end)

  it('should interpolate', do ()
    ('{1} + {2} is {1 + 2}'):expect('1 + 2 is 3')
  end)
end)

describe('Block', do ()
    let a = 1

    it('should capture', do ()
        a:expect(1)

        def test()
           a:expect(1)
           a  
        end

        test():expect(1)
        test():expect(1)
        test():expect(1)
    end)

    it('should capture by reference', do ()
        let b = 2

        def addOne()
            b = b + 1
        end

        b:expect(2)

        addOne()

        b:expect(3)

        addOne()
        addOne()

        b:expect(5)
    end)
end)

describe('Records', do ()
  it('should have properties', do ()
    let Point = {
      x: 1
      y: 2
    }

    Point.x:expect(1) and
    Point.y:expect(2)
  end)

  it('should be structurally shaped', do ()
    let pone = { x: 1 y: 2}
    let ptwo = { x: 3 y: 4}

    (pone?):expect(ptwo?)
  end)

  it('should set properties dynamically', do ()
    let obj = { [[]?]: 'test' }
    obj['y'] = 2

    (obj.y):expect(2) and
    (obj[[]?]):expect('test')
  end)

  it('should work for all kinds of keys', do ()
    let obj = {}
    obj[obj] = 2
    obj[{}?] = 3

    let i = do ()
      1
    end

    obj[i] = i 

    obj[obj]:expect(2) and
    obj[{}?]:expect(3) and
    obj[i]:expect(i)
  end)

  it('should spread out the keys', do ()
    let obj = {
      test: 'hello'
      [{}?]: 'world'
    }

    let a, b = ..obj
    let c, d = ..obj?

    a:expect('hello') and
    b:expect('world') and
    c:expect('test') and
    d:expect({}?)
  end)

  it('should withstand this tricky mess', do ()
    let obj = {}

    def try_segfault()
      { try: 'segv' }
    end

    obj[try_segfault()] = 2

    (..obj):expect(2)
    (..((..obj?)?)):expect('try')
  end)
end)

describe('Messages', do ()
    def test[]
        self    
    end

    it('Should send', do ()
        1:test:expect(1)
    end)

    def test[1?]
        self + 1
    end

    it('Should use more specific', do ()
        1:test:expect(2)
    end)

    def repeat()
        1:test
    end

    it('Should cache', do ()
        repeat():expect(2)
        repeat():expect(2)
        repeat():expect(2)
    end)
end)

describe('Effects', do ()
    def once()
        yield 1
        2
    end

    def twice()
        yield 1
        yield 2

        3
    end

    def receive_one()
        let val = yield

        val:expect(1)
    end

    def receive_onetwo()
        let one, two = yield
        
        one:expect(1) and
        two:expect(2)
    end

    def onetwo()
        return 1,2 
    end

    def yields_many()
        yield onetwo()
    end

    it('should yield once', do ()
        let val, eff = once()

        val:expect(1) and
        eff():expect(2)
    end)

    it('should yield twice', do()
        let _, eff = twice()

        let valtwo, efftwo = eff()

        valtwo:expect(2) and
        efftwo():expect(3)
    end)

    it('should receive a value', do ()
        let eff = receive_one()

        eff(1)
    end)

    it('should yield var', do ()
        let one, two, eff = yields_many()
        one:expect(1) and
        two:expect(2)
    end)

    it('should receive var', do ()
        let eff = receive_onetwo()

        eff(onetwo())
    end)


end)
