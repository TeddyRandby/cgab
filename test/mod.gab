'std':require

def describe(name, cb)
  ('\n--{name}--'):print
  cb()
end

def it(name, cb)
  print('{cb() and '✓' or '×'} it {name}')
end

def check(result, msg)
  result or print(msg)
end

def expect[](other)
  check(self == other, 'Expected {self} to be equal to {other}') or panic()
end

def expect_not[](other)
  check(not (self == other), 'Expected {self} to not be equal to {other}') or panic()
end

describe('Numbers', do ()
  it('should be equal to itself', do ()
    5:expect(5)
  end)

  it('should do math', do ()
    (5 * 2):expect(10)
    (10 % 3):expect(1)
  end)
end)

describe('Strings', do ()
  it('should be equal to itself', do ()
    'hello':expect('hello')
  end)

  it('should concatenate', do ()
    ('hello' + ' world'):expect('hello world')
  end)

  it('should interpolate', do ()
    ('{1} + {2} is {1 + 2}'):expect('1 + 2 is 3')
  end)
end)


describe('Closures', do ()
    let a = 1

    it('should capture', do ()
        a:expect(1)

        def test()
           a:expect(1)
           a  
        end

        test():expect(1)
        test():expect(1)
        test():expect(1)
    end)

    it('should capture by reference', do ()
        let b = 2

        def addOne()
            b = b + 1
        end

        b:expect(2)

        addOne()

        b:expect(3)

        addOne()
        addOne()

        b:expect(5)
    end)

   it('should work with varargs', do()

      def varfunc(first, ..args)
        first:expect(1)
        args[0]:expect(2)
      end

      varfunc(1,2)

      def onetwo()
        return 1, 2
      end

      varfunc(onetwo())
   end)
end)

# describe('Lists', do ()
    # def list = [1 2 3]

    # list[0]:expect(1)

    # list[1]:expect(2)

    # list[2]:expect(3)

    # list[1] = 4

    # list[1]:expect(4)
# end)

describe('Records', do ()
  def Point { x y }

  it('should have properties', do ()
    let point = {
      x = 1
      y = 2
    }

    point.x:expect(1)
    point.y:expect(2)
  end)

  it('should be structurally shaped', do ()
    let pone = { x = 1 y = 2}
    let ptwo = { x = 3 y = 4}

    (pone:type):expect(ptwo:type)
  end)

  it('should work for all kinds of keys', do ()
    let obj = {
        [{}:type] = 3
        [it]  = it
    }

    obj[{}:type]:expect(3)
    obj[it]:expect(it)
  end)

  it('should work when shapes change', do ()
    let justa = { a }
    let ab = { a = 3 b }
    let abc = { a = 'hi' b c}

    def get_a[]
        self.a
    end
    
    justa:get_a:expect(true)

    ab:get_a:expect(3)

    abc:get_a:expect('hi')

    ab:get_a:expect(3)
    ab:get_a:expect(3)

    ab.a = 5

    abc:get_a:expect('hi')

    ab:get_a:expect(5)
    justa:get_a:expect(true)
  end)

  it('should make tuples', do ()
    let tup = [ 1 2 3 ]

    tup[0]:expect(1)
    tup[1]:expect(2)
    tup[2]:expect(3)
  end)
end)

describe('Overloads', do ()
    def Vector { x y }

    def __add__[Vector](other)
        other is Vector then
            {
                x = self.x + other.x
                y = self.y + other.y
            }
        end
    end

    it('should overload binary', do ()
        let test = { x=1 y=2 } + { x=2 y=1 }

        test.x:expect(3)
        test.y:expect(3)
    end)

    def __lt__[Vector](other)
        other is Vector then
            let mag = self.x * self.x + self.y * self.y
            let other_mag = other.x * other.x + other.y * other.y

            mag < other_mag
        end
    end

    def __eq__[Vector](other)
        (self.x == other.x) and (self.y == other.y)
    end

    it('should overload comparison', do ()
        let test = { x=1 y=1 } < { x=4 y=4 }
        test:expect(true)

        test = { x=1 y=1 } == { x=1 y=1 }

        test:expect(true)
    end)

    def get(obj, key)
        obj[key]
    end

    it('should get before overload', do()
        get({ x = 1 y = 2}, 'x'):expect(1)
    end)


    def __get__[Vector](key)
       key == 'mag' then
        self.x * self.x + self.y * self.y
       end
    end

    it('should overload get', do ()
        get({ x = 2 y = 2 },'mag'):expect(8)
    end)

    it('should behave when switching types', do ()

      def sum(a,b)
        a + b
      end

      sum(1,2):expect(3)
      sum('h','i'):expect('hi')
      sum({x = 1 y = 2}, {x = 2 y = 1}):expect{x = 3 y = 3} # Should work because of eq overload
      sum(1,2):expect(3)
      sum('h','i'):expect('hi')
    end)
end)

describe('Messages', do ()
    def test[]
        self    
    end

    it('should send', do ()
        1:test:expect(1)
    end)

    def test[1:type](a)
        self + 1
    end

    it('should use more specific', do ()
        1:test:expect(2)
    end)

    def repeat()
        1:test
    end

    it('should cache', do ()
        repeat():expect(2)
        repeat():expect(2)
        repeat():expect(2)
    end)

    def oneTwo()
      return 1, 2
    end

    it('should send/receive var', do ()
      def takeOneTwo(a, b)
        a:expect(1)
        b:expect(2)
      end

      takeOneTwo(oneTwo())
    end)
end)

describe('Effects', do ()
    def once()
        yield 1
        2
    end

    def twice()
        yield 1
        yield 2

        3
    end

    def receive_one()
        let val = yield

        val:expect(1)
    end

    def receive_onetwo()
        let one, two = yield
        
        one:expect(1)
        two:expect(2)
    end

    def onetwo()
        return 1,2 
    end

    def yields_many()
        yield onetwo()
    end

   it('should yield once', do ()
       let val, eff = once()

       val:expect(1)
       eff():expect(2)
   end)

    it('should yield twice', do()
        let _, eff = twice()

        let valtwo, efftwo = eff()

        valtwo:expect(2)
        efftwo():expect(3)
    end)

   it('should receive a value', do ()
       let eff = receive_one()

       eff(1)
   end)

   it('should yield var', do ()
       let one, two, eff = yields_many()
       one:expect(1)
       two:expect(2)
   end)

   it('should receive var', do ()
       let eff = receive_onetwo()

       eff(onetwo())
   end)
end)

describe('Lists', do ()
    it('should create', do ()
        let list = List:new(100)

        list:expect_not(nil)
    end)

    it('should put', do ()
        let list = List:new

        list:at(0):expect(nil)

        list:push('hello')

        list:at(0):expect('hello')

        list:put(2, 'hello')

        list:at(2):expect('hello')
    end)

    it('should get/set', do ()
        let list = List:new

        list[0]:expect(nil)

        list[0] = 5

        list[0]:expect(5)

        list[10] = 10

        list[10]:expect(10)

        list[9]:expect(nil)
    end)

    it('should index with range', do ()
        let list = List:new(5)
        list[0] = 1
        list[1] = 2
        list[2] = 3
        list[3] = 4
        list[4] = 5

        let slice = list[3:to]

        slice:at(0):expect(1)
        slice:at(2):expect(3)

        slice = list[3:to(4)]

        slice:at(0):expect(4)
        slice:at(1):expect(nil)
    end)
end)

describe('Maps', do ()
  it('should create', do ()
    let map = Map:new

    map:expect_not(nil)
  end)

  it('should create with initial', do ()
    let map = Map:new { hi = 'bob' }

    map:expect_not(nil)

    map:at('hi'):expect('bob')
  end)

  it('should put', do ()
    let map = Map:new

    map:put('hi', 'bob')

    map:at('hi'):expect('bob')
    map:at('bye'):expect(nil)
  end)

  it('should get/set', do ()
    let map = Map:new

    map['hi'] = 'bob'

    map['hi']:expect('bob')
    map['bye']:expect(nil)
  end)
end)
