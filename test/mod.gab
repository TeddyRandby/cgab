require('std')

require('Test')

:describe('Numbers') do
  :it('should be equal to itself') do
    5:expect(5)
  end

  :it('should do math') do
    10:expect(5 * 2)
    1:expect(10 % 3)
    8:expect(1 << 3)
  end

  :it('should compare') do
    5:expect(10, &<)
    10:expect(5, &>)
  end
end

:describe('Strings') do
  :it('should be equal to itself') do
    'hello':expect('hello')
  end

  :it('should concatenate') do
    'hello world':expect('hello' + ' world')
  end

  :it('should interpolate') do
    '1 + 2 is 3':expect('{1} + {2} is {1 + 2}')
  end
end


:describe('Closures') do
    def a = 1

    :it('should capture') do
        a:expect(1)

        def test = do
           a:expect(1)
           a  
        end

        test():expect(1)
    end

   :it('should work with varargs') do
      def varfunc = do (first, ..args)
        first:expect(1)
        args[0]:expect(2)
      end

      varfunc(1,2)

      def onetwo = do return 1, 2 end

      varfunc(onetwo())
   end
end

:describe('Records') do
  def Point { x y }

  :it('should have properties') do
    let point = {
      x = 1
      y = 2
    }

    point.x:expect(1)
    point.y:expect(2)
  end

  :it('should be structurally shaped') do
    let pone = { x = 1 y = 2}
    let ptwo = { x = 3 y = 4}

    ?pone:expect(?ptwo)
  end

  :it('should work for all kinds of keys') do
    let obj = {
        [?{}] = 3
        [$hi] = 3
    }

    3:expect(obj[?{}])
    4:expect(obj[$hi])
  end

  :it('should work when shapes change') do
    let justa = { a }
    let ab = { a = 3 b }
    let abc = { a = 'hi' b c}

    def get_a[?{ a }]
        self.a
    end

    def get_a[?{ a b }]
        self.a
    end
    
    def get_a[?{ a b c }]
        self.a
    end
    
    true:expect(justa:get_a)

    3:expect(ab:get_a)

    'hi':expect(abc:get_a)

    3:expect(ab:get_a)
    3:expect(ab:get_a)

    ab.a = 5

    'hi':expect(abc:get_a)

    5:expect(ab:get_a)
    true:expect(justa:get_a)
  end

  :it('should make tuples') do
    let tup = [ 1 2 3 ]

    1:expect(tup[0])
    2:expect(tup[1])
    3:expect(tup[2])
  end
end

:describe('Overloads') do
    def Vector { x y }

    def + [Vector](other)
        other is Vector or panic()

        {
            x = self.x + other.x
            y = self.y + other.y
        }
    end

    :it('should overload binary') do
        let test = { x=1 y=2 } + { x=2 y=1 }

        3:expect(test.x)
        3:expect(test.y)
    end

    def < [Vector](other)
        other is Vector or panic()

        let mag = self.x * self.x + self.y * self.y
        let other_mag = other.x * other.x + other.y * other.y

        mag < other_mag
    end

    def == [Vector](other)
        (self.x == other.x) and (self.y == other.y)
    end

    :it('should overload comparison') do
        { x = 1 y = 1 }:expect({ x = 1 y = 1})
        { x = 1 y = 2 }:expect({ x = 4 y = 4}, &<)
    end

    def get = do (obj, key)
        obj[key]
    end

    :it('should get before overload') do
        1:expect(get({ x = 1 y = 2}, 'x'))
    end


    def [] [Vector](key)
       key == 'mag' then
        return self.x * self.x + self.y * self.y
       end
    end

    :it('should overload get') do
        8:expect(get({ x = 2 y = 2 },'mag'))
    end

    :it('should behave when switching types') do
      def sum = do (a,b)
        a + b
      end

      3:expect(sum(1,2))
      'hi':expect(sum('h','i'))
      {x = 3 y = 3}:expect(sum({x = 1 y = 2}) {x = 2 y = 1})
      {x = 3 y = 3}:expect(sum({x = 1 y = 2}) {x = 2 y = 1})
      'hi':expect(sum('h','i'))
      3:expect(sum(1,2))
    end
end

:describe('Messages') do
    def test[]
        self    
    end

    :it('should send') do
        1:expect(1:test)
    end

    def test[Number](a)
        self + 1
    end

    :it('should use more specific') do
        2:expect(1:test)
    end

    def repeat = do 1:test end

    :it('should cache') do
        2:expect(repeat())
        2:expect(repeat())
        2:expect(repeat())
    end

    def oneTwo = do return 1, 2 end

    :it('should send/receive var') do
      def takeOneTwo = do (a, b)
        1:expect(a)
        2:expect(b)
      end

      takeOneTwo(oneTwo())
    end
end

:describe('Effects') do
    def once = do
        yield 1
        2
    end

    def twice = do
        yield 1
        yield 2

        3
    end

    def receive_one = do
        let val = yield

        1:expect(val)
    end

    def receive_onetwo = do
        let one, two = yield
        
        1:expect(one)
        2:expect(two)
    end

    def onetwo = do
        return 1,2 
    end

    def yields_many = do
        yield onetwo()
    end

   :it('should yield once') do
       let val, eff = once()

       1:expect(val)
       2:expect(eff())
   end

   :it('should yield twice') do
       let _, eff = twice()

       let valtwo, efftwo = eff()

       2:expect(valtwo)
       3:expect(efftwo())
   end

   :it('should receive a value') do
       let eff = receive_one()

       eff(1)
   end

   :it('should yield var') do
       let one, two, eff = yields_many()
       1:expect(one)
       2:expect(two)
   end

   :it('should receive var') do
       let eff = receive_onetwo()

       eff(onetwo())
   end
end

:describe('Lists') do
    :it('should create') do
        let list = :list(100)

        list:expect_not(nil)
    end

    :it('should put') do
        let list = :list

        list:at(0):expect(nil)

        list:push('hello')

        list:at(0):expect('hello')

        list:put(2, 'hello')

        list:at(2):expect('hello')
    end

    :it('should get/set') do
        let list = :list

        list[0]:expect(nil)

        list[0] = 5

        list[0]:expect(5)

        list[10] = 10

        list[10]:expect(10)

        list[9]:expect(nil)
    end

    :it('should index with range') do
        let list = :list(5):map! do (_, i) i + 1 end

        let slice = list[3:to]

        slice[0]:expect(1)
        slice[2]:expect(3)

        slice = list[3:to(4)]

        slice[0]:expect(4)
        slice[1]:expect(nil)
    end
end

:describe('Maps') do
  :it('should create') do
    let map = :map

    map:expect_not(nil)
  end

  :it('should create with initial') do
    let map = :map { hi = 'bob' }

    map:expect_not(nil)

    map:at('hi'):expect('bob')
  end

  :it('should put') do
    let map = :map

    map:put('hi', 'bob')

    map:at('hi'):expect('bob')
    map:at('bye'):expect(nil)
  end

  :it('should get/set') do
    let map = :map

    map['hi'] = 'bob'

    map['hi']:expect('bob')
    map['bye']:expect(nil)
  end
end
