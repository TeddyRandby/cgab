m = 'msg' :use
'list' :use

\deftransducer! :impl! (['gab.sigil', 'gab.string'], do td
  public, private = m:message.new self, m:message.new 'do_{self}'

  public :impl! ([], do m, init, f
    i = self

    private :case! {
      .ok = do current, next
        (
          td(f, current**),
          do
            status, next_value[], next_next = m(i, next)
            
            private(status, next_value, next_next)
          end,
        )
      end,
      .done = do; .false end,
    }

    status, current[], next = m(i, init)

    private(status, current, next)
  end)
end)

.map :deftransducer! do f, current[]
  f(current**)
end

# A consumer is a message which takes at three arguments:
# (invariant ie. a list, producer ie. \values, initial ie. 0, args ie. \print)
# [1,2,3] :for (\values, 0, \print)
# The consumer uses the producer completely, and not lazily.
# 
# A producer is a message which takes two arguments:
# (invariant ie. a list, variant ie. the accumulator)
# It returns:
#   - .some, <values>[], <next-variant>
#   - .none
#

\list.values.next? :impl!(['gab.list'], do n
  self:len > n
end)

\list.values.continue :case! {
  .true = do list, n
    (.ok, list:at(n), n + 1)
  end,
  .false = do
    .done
  end
}

\values :impl!(['gab.list'], do n
  self :list.values.next? n :list.values.continue(self, n)
end)

list = .nil:list.new

list:push!(1,2,3)

_, n = list:map(\values, 0, \print)
_, n = n()
_, n = n()
_, n = n()

_, n = list:map(\values, 0, do x; x + 1 end )
