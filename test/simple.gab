'msg' :use
'list' :use

#\map :deftransducer! do f
#  {
#    .step = do x, acc, rf
#      rf(acc, f x)
#    end,
#  }
#end

\deftransducer! :impl! (['gab.message'], do m, td
  m :impl! ([], do i, m, init, f
    m :case! {
      .ok = do _, current[], next
        (
          td(f, current**),
          do
            m(m(i, next))
          end,
        )
      end,
      .done = do; .done end,
    }

    m(m(i, init))
  end)
end)

\map :deftransducer! do _, f, current[]
  f (current**)
end

# A consumer is a message which takes at three arguments:
# (invariant ie. a list, producer ie. \values, initial ie. 0, args ie. \print)
# [1,2,3] :for (\values, 0, \print)
# The consumer uses the producer completely, and not lazily.
# 
# A producer is a message which takes two arguments:
# (invariant ie. a list, variant ie. the accumulator)
# It returns:
#   - .some, <values>[], <next-variant>
#   - .none
#

\list.values.next? :impl!(['gab.list'], do self, n
  self:len > n
end)

\list.values.continue :case! {
  .true = do _, list, n
    (.ok, list:at(n), n + 1)
  end,
  .false = do
    .done
  end
}

\values :impl!(['gab.list'], do self, n
  self :list.values.next? n :list.values.continue(self, n)
end)

list = .new :list.new

list:push!(1,2,3)

_, n = list:map(\values, 0, \print)


_, n = n()
_, n = n()
_, n = n()
