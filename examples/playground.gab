'specs' :use

## cars.gab
Car = { car.make, car.model, car.year, car.color }

'car.make' :def.spec! {
  help = "The car's manufacturer, ie 'Ford'",
  spec =  .spec.or  ('Ford', 'Chevy', 'Toyota', 'Honda'),
}

'car.year' :def.spec! {
  spec =  .spec.and ( .spec.int (),  .spec.gt 2000 )
}

'car.color' :def.spec! {
  spec =  .spec.or ('RED', 'BLUE', 'WHITE', 'BLACK')
}

'car.model' :def.spec! {
  spec =  .spec.or ('Mustang', 'Civic', 'Camry', 'Prius')
}

'car' :def.spec! {
  spec =  .spec.protocol Car
}

car.paint.spec =  'car.paint' :def.spec! {
    help = "Paint the car with the given color",
    spec =  .spec.message {
      # The receiver's spec
      receiver =  'car' :spec,
      # The message we spec over
      message  = \car.paint,
      # Fetch the spec 'car.color' for the input
      input    =  'car.color' :spec,
      # Fetch the spec 'car.color' for the output
      output   =  'car.color' :spec,
      # Validate the implementation
      semantics = do receiver, input, output
        (input:at!(0) == receiver:car.color) & (input:at!(0) == output:at!(0))
      end,
    }
}

# Generate a mock car
# test_car = car.spec spec.gen

# Test the mock coar with the mock implementation of car.paint
# test_car car.paint('BLUE')  print # => 'BLUE'

# Generate a mock implementation of car.paint for Car
# car.paint.spec spec.gen(Car)

# Define a faulty car.paint specialization
\car.paint :def! ([Car], do color
  self:car.color = 10
end)

car.paint.spec:spec.explain:print

# Check our faulty implementation
# & spec.check yields a stream of predicate results.
# It generates receivers and inputs, sends the message,
# And checks the output against the spec and semantics.
# This code will run forever if the spec is always satisfied
_, spec, value, path = car.paint.spec:first(\spec.check, do ok, spec, value, path
     ok  :or do; (.some, spec, value, path) end
  end)

'result:':print(spec, value, path)
