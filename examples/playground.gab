'specs' :use

Car = { car.make, car.model, car.year, car.color }

'car.make' :def.spec! {
  help = "The car's manufacturer, ie 'Ford'",
  spec =  .spec.or  ('Ford', 'Chevy', 'Toyota', 'Honda'),
}

'car.color' :def.spec! {
  spec =  .spec.or ('RED', 'BLUE', 'WHITE', 'BLACK')
}

'car.model' :def.spec! {
  spec =  .spec.or ('Mustang', 'Civic', 'Camry', 'Prius')
}

'car.year' :def.spec! {
  spec =  .spec.and ( .spec.int (),  .spec.gt 2000 )
}

car.spec = 'car' :def.spec! {
  spec =  .spec.protocol Car
}

car.paint.spec =  'car.paint' :def.spec! {
    help = "Paint the car with the given color",
    spec =  .spec.message {
      # The receiver's spec
      receiver =  'car' :spec,
      # The message we spec over
      message  = \car.paint,
      # Fetch the spec 'car.color' for the input
      input    =  'car.color' :spec,
      # Fetch the spec 'car.color' for the output
      output   =  'car.color' :spec,
      # Validate the implementation
      semantics = do receiver, input, output
        (input:at!(0) == receiver:car.color) & (input:at!(0) == output:at!(0))
      end,
    }
}

# Generate a mock car
test_car = car.spec :spec.gen

# Generate a mock implementation of car.paint for Car
car.paint.spec:spec.gen(Car?)

# Test the mock coar with the mock implementation of car.paint
test_car :car.paint('BLUE'):print # => 'BLUE'

# Define a faulty car.paint specialization
#\car.paint :def! ([Car?], do color
#  self:car.color = 10
#end)

# Check our faulty implementation
# & spec.check yields a stream of predicate results.
# It generates receivers and inputs, sends the message,
# And checks the output against the spec and semantics.
# This code will run forever if the spec is always satisfied
results[] = car.paint.spec:spec.check
